/*===================================================
■■■ 컬렉션 프레임워크(Collection Framework) ■■■
====================================================*/
// 자바가 거의 끝나간다.
// 클래스, 객체, 인스턴스 이 내용 모르면 자바 개발자 아님.
// 인터페이스
// 컬렉션 프레임워크도 중요!


/*
○ 컬렉션 프레임워크(Collection Framwork)
   = 컬렉션(Collection) + 프레임워크(Framework)
   						  ---------------------
						     환경, 틀, 약속
							 ----
							 자바로 프로그램 만들 때 JDK,JDM 필요해
							       ---
								   어느 계층에서는 이거해야돼
								        ----
										중국집 오늘의 메뉴
	--------------------
	         |
			 |
			 |
			집합 → 수집품, 소장품, (물건? 사람들?의) 무리, 더미, 수집, 수거 등
					-----------------------------------------------------------
					             모아놓은 것들... 모여있는 것들...


   ==>> 자료 구조

   『개발자의 숙명 : 자료구조와 알고리즘은 평생 공부.』
   				   메소드의 재귀호출, 재귀호출할 때 말했을거야.


○ 자료
   현실 세계로부터 단순한 관찰이나 측정을 통해 수집된
   사실이나 개념의 값들 또는 그 값들의 집합.

   ↓

○ 자료구조
   자료 처리를 위한 자료의 표현, 저장, 관계, 관리 및
   이용에 관한 방법 등의 개념을 이해하여 프로그램에 사용하고
   컴퓨터에 의해 처리되는 과정에서 적절한 자료의 표현, 구성, 저장 및
   처리를 위한 알고리즘의 작성 및 선택과 이용 방법을 연구하는 분야.
   
   ↓

○ 컬렉션 프레임워크(Collection Framework)
   컬렉션(모아놓은 데이터들)의 표현과 조작을 위한 통일된 아키텍처로
   컬렉션 프레임워크를 구성하는 요소는 다음과 같다.

   1. 인터페이스(Interface)
      기본적으로 컬렉션에 필요한 데이터 관리 기능을 제공한다.
	  예를 들어 list는 추가, 삭제, 검색 등의 기능을 제공하는
	  컬렉션 인터페이스가 존재하며
	  각 컬렉션마다 고유의 인터페이스가 정의되어 있다.

   2. 구현(Implenmentation)
      인터페이스를 구현한 클래스로 각 컬렉션을
	  실제 어떤 자료구조를 이용하여 표현했느냐에 따라
	  컬렉션의 종류가 달라지게 된다.

   3. 알고리즘(Algorithms)
      각 컬렉션들마다 유용하게 사용할 수 있는 메소드를 의미한다.


※ 자바 컬렉션은 견고한 컬렉션 프레임워크 기반 위에 정의되어 있으므로
   각 컬렉션 종류마다 제공되는 메소드의 일관성이 있기 때문에
   한 가지 컬렉션을 익혀두면 다른 컬렉션을 사용하는데 용이하다.

리스트 인터페이스 : 순서가 있다!(like 배열), 순서가 의미 있는 자료구조(명단...)
셋 자료구조       : 순서가 의미 없는 자료구조! (주머니안에 빨간공, 파란공..)
맵 자료구조		  : 생긴건 셋자료구조랑 똑같은데(주머니) 구슬에 실달림. 구분가능!
														 value	key
														 이게 쌍으로 달린게 맵
리스트, 셋 → 컬렉션 인터페이스 
맵은 단독

*/
/*
○ 스택(Stack)
   
   Stack 클래스는 오브젝트 후입선출(LIFO) 구조의 Stack 을 나타낸다.
   이는 벡터(Vector)를 스택으로 처리하는 5개의 메소드로
   벡터(Vector) 클래스를 확장하게 된다.

   통상의 push() 메소드와 pop() 메소드가 제공되는 것 외에
   스택의 선두 항목으로 peek() 을 실시하는 메소드,
   스택이 비어있는지의 여부를 확인하는 메소드 isEmpty(),
   스택으로 항목을 찾아서 선두로부터 몇 번째인지 찾아내는 메소드 등이 제공된다.

   스택이 처음으로 작성되었을 때, 항목은 존재하지 않는다.

   - boolean empty()
     스택이 비어있는지 확인한다.
   
   - E Object peek()
     스택의 맨 위의 객체를 스택에서 제거하지 않고 반환한다.

   - E Object pop()
     스택의 맨 위의 객체를 반환하고 스택에서 제거한다.

   - E Object push(E item)
     객체를 스택 자료구조에 저장한다.

   - int search(Object o)
     스택의 맨 위에서부터 파라미터 값으로 넘겨받은 객체까지의 거리를 반환한다.
	 맨 위의 객체의 경우 1을 반환하고 그 아래 객체는 2를 반환하는 형식.


컬렉션 프레임워크의 Stack은 배열이랑 다름.
동질의 데이터 모임 ㄴㄴ 군. → 무리 군. 군집을 이루다.
일관적으로 처리하면 데이터 중에 훼손되는게 있어.
→ 그릇에 표시를 함. 여기엔 뭘 담을거야~ 이거
단일 데이터 : 변수
*/

// 제네릭, 제네릭 표현식(그릇에 표시) 정의할 때, 설계할 때, 사용할 때 명시.
// 그릇에서 하나를 꺼냈을 때 다 담고 있으면 꺼낼 때
// 뭐가 나오는지 몰라 그러면 변수에 담을 수 없음.

import java.util.Stack;

public class Test156
{
	public static void main(String[] args)
	{
		//Stack 자료구조 생성
		Stack<Object> myStack = new Stack<Object>();
		//   --------                    --------
		//   제네릭                       제네릭
		// Object는 모든 객체의 상위 클래스이기 때문에
		// 무엇을 담아도 상관없다라는 뜻이 됨.
//=======================================================================
		String str1 = "홍은혜";
		String str2 = "최문정";
		String str3 = "이연주";
		String str4 = "이시우";
 //=======================================================================
		//myStack 이라는 Stack 자료구조 안에 str1 ~ str4 까지 담아내기
		// add(), push()   호환성 때문에 유사한 메소드들이 있다.
		myStack.add(str1);
		myStack.add(str2);
		myStack.push(str3);
		myStack.push(str4);
//=======================================================================
		//peek() : 스택 맨 위의 객체 반환. 제거하지 않는다.
		String val1 = (String)myStack.peek(); //-- 다운 캐스팅
		System.out.println("val1 : " + val1);
		//--==>>val1 : 이시우 
		//      맨 위에 거 (마지막에 담은거) 나옴.

//=======================================================================
		String val2 =(String)myStack.peek();
		System.out.println("val2 : " + val2);
		//--==>>val2 : 이시우
		//      peek()은 제거하지 않기 때문에 이시우 출력. 
		//      즉, 맨 위에 거만 봄.
		//      스택 자료구조 특성상, 맨 위가 없어져야 차례대로 나옴.
//=======================================================================
		String value = "";
		
		//myStack 이라는 이름을 가진 Stack 자료구조에
		//데이터가 비어있지 않은 상태라면 ....(즉, 채워져 있는 상태라면...)
		//isEmpty()
		while (! myStack.isEmpty()) // 아니다. myStack에 Empty이면 true → !false → true
		{
			// pop() : 스택 맨 위의 객체 반환. 제거한다.
			value = (String)myStack.pop(); // 다운캐스팅, 이시우객체를 String으로 형변환해서 value에 담는다~ 그리고 제거한다.
			System.out.println("value : " + value);
		}
		//여기까지오면 암거도 없음.
		// 배열은 여기 인덱스 몇번에 누구요 ~ 이거임.
		/*
		value : 이시우
		value : 이연주
		value : 최문정
		value : 홍은혜
		*/
	}
}

