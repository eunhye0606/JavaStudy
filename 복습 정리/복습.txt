자바 기본 프로그래밍
Test001.java
-클래스 첫 이름은 대문자로 시작.
-mian()함수는 자바 인터프리터가 처음 찾는 함수
-메소드() : 호출하다.
-자바에서 함수(메소드)는 독립적으로 존재할 수 없다.
-→ 클래스에 정의되는 형태로 함수를 만든다.
-그래서 다른 학문(수학 등)에서 말하는 함수와 차이가 있다.
-→ 그래서 자바에서의 함수는 메소드라고 부른다.
-함수,메소드 → 기능,동작,행위
-메소드는 정의되어야 호출(println())으로 호출할 수 있다.

Test002.java
-컴파일 실행 실습

자바의 개요 및 특징
Test003.java
-println()메소드는 마지막에 라인 스킵(개행)을 한다.
-print()는 하지않는다.

자바 기본 프로그래밍
Test004.java
-변수와 자료형
-자료형 변수명; //-- 변수 선언
-변수명 = 값; //-- 초기화
-자료형 변수명 = 값 //-- 변수 선언 및 초기화 한번에
-자바에서는 '='대입연산자가 나오면 오른쪽 부터 처리를 해라!
-컴파일 에러 : javac.exe가 찾는다.
-런타임 에러 : 개발자의 의도와 다른 형태로 사용자가 사용할 때 나는 에러.
-알파테스트(개발자), 베타테스트(개발자가 아닌사람들의 테스트)
-클로즈테스트(특정 사용자가 대상), 오픈테스트(아무나),
-덧셈 연산자(+)는 피연산자 중 어느 하나라도 문자열 형태이면 ""
 산술연산자로써의 기능을 하지 않는다. 문자열 결합 연산자로 기능한다
 →처리 결과는 문자열 형태로 반환한다.
 뺄셈 연산자는 그런 기능이 없다!

Test005.java
-변수와 자료형
-변수 선언 → 메모리 공간 확보 / 할당
 자바야 자바야 나 int형 4byte로 변수 선언할거니까 자리예약좀 !!
- 연산 및 처리 → 확보한 메모리 공간에 데이터 담아내기
- '=' 대입 연산도 연산이다! 대입 연산자!!
-자동형변환, 명시적형변환

Test006.java
-변수와 자료형
-키워드 및 식별자
-스코프 영역 안에서 변수명은 식별자이다!!
 식별자 : 구분하기 위한
-문법적으로 변수명을 한글로는 가능하지만 실무에서 사용하지는 않는다!

Test007.java
-print() / println() / printf() / format()
-printf(), format()은 JDK 1.5부터 지원되는 메소드
-두 개 사용법은 같다.
-format()은 String에서 자주 쓴다.
-System.out.printf("○ + ○ + ○", 10, 20, 30);
-System.out.format("○ + ○ + ○", 10, 20, 30);
-서식 출력용 메소드
-출력하기 위해 틀짜놓고 하는것.
-메소드 뒤에 ln이 없기에 print()메소드 처럼 개행이 안된다.
-그래서 \n 혹은 %n으로 개행출력.
-%d == 10진수 정수형 ( 1, 10, 94 .. )
-%f == 실수(3.14 ...)
-%.2f : 소수점 이하 두 번째 자리까지 표현
        반올림함.
-%d로 틀짜고 실수를 넣으면 런타임에러가 발생한다 (컴파일에러는 문법을 봄)
-문법은 맞는데 개발자가 정수를 목적으로 코드 짰는데
 사용자가 실수를 넣어서 런타임 에러 발생.

Test008.java
-형 변환
-접미사활용
 1바이트 2바이트 4바이트  8바이트   4바이트(실수)  8바이트(실수)
-byte   < short   < int    < long   < float       < double
          char  
         2바이트
-boolean
  1바이트

//자료형의 종류와 구분
자료형		데이터		메모리 크기		표현 가능 범위
boolean		참과 거짓	1바이트			T,F

char		문자		2바이트			모든 유니코드 문자

byte		정수		1바이트			-128~ 127
short		정수		2바이트			-32768~ 32767
int		정수		4바이트			+- 21억
long		정수		8바이트			매우 큰 정수


float		실수		4바이트			매우 큰 실수
double		실수		8바이트			더 큰 실수




//자료형 변환

byte → short  ↘ 
		  int →long →float →double
        char   ↗

-자동형변환 : 큰거에 작은거는 자동으로 담긴다 (short가 long에 담긴다)
-명시적형변환(강제형변환), 자동형변환 위배가 아니더라도 
 어디서 형변환 된지 알려줄라고 쓸 때도 있삼!
int a;
char c;
a = c; → int형(4바이트 정수)에 char(2바이트 문자형) → 담긴다 → 자동형변환
c = a; → char(2바이트 문자형)에 int(4바이트 정수형) → 담기지 않음 → 자동형변환 위배
          작은그릇에 큰거 담을 수 없음
          c = (char)a; 
          a의 크기가 2바이트에 담길 크기면 명시적형변환으로 가능
long d = 10000000000;	//백억임
'=' 대입 연산자를 기준으로 우측의 상수 표현이
    int형 메모리에 해당 상수를 할당할 수 없다. 그래서 long으로 자료형 선언
    21억을 넘는다. 그래서 접미사 L을 뒤에 붙혀야 한다...

long d = 10000000000L; O
long d = 10000000000; X
int d = 10000000000; X
int d = 10000000000L; X

int e = 030;
System.out.println("e의 결과:" + e);
		//-->e의 결과:24
접두어 0 → 8진수로 바꿔줌.
030 →64, 8, 1 
8 x 3 = 24이기 때문에 24가됨.

Test009.java
-변수와 자료형 실습 및 테스트 : boolenan

Test010.java
-변수와 자료형 실습 및 테스트 : char
- '' 는 문자형 "" 은 문자열형
- char ch2 = '\n' → \n도 하나의 문자입니다~!

Test011.java
//나눗셈 연산 실습
- 정수와 정수의 나눈셈 ( 몫 반환 ) 
- 피 연산자로 실수가 포함되어 있는 나눗셈
  실수 기반의 연산 수행.
Like 덧셈 연산자는 피연산자가 문자열or 문자가 있으면 문자열 결합 연산자로 수행.



Test012.java
-원의 넓이와 둘레를 구하는 프로그램 구현
- final → 변수의 상수화하는 키워드
- 변수는 수시로 변할 수 있다.
  상수는 변하지 않는다 이름 없는 특징
- final 변수는 대문자로 쓰는 암묵적 룰!
- 언더바스코어 표기법 

Test013.java
-직사각형의 넓이와 둘레를 구하는 프로그램 구현

Test014.java
-자바의 기본 입출력 : BufferedReader 클래스
-버퍼 : 임시기억공간, Like 키보드같은 장치
-throws IOException : 오류나면 그 오류 메소드 밖으로 던질게 자바

BufferedReader br = new BufferedReader(new InputStreamReaer(System.in)); 
                                                           -----------
                                                           바이트 입력값
                                       ---------------------------------
                                       바이트 → 문자 번역기
---------------------------------------
        문자 입력을 읽어들이는 장치
br.readLine(); → BufferedReader의 readLine() → 문자열 반환!
Integer.parseInt() → 매개변수로 넘겨받은 문자열 데이터 → 정수형으로 변환
단, 이 때 넘겨받은 문자열 데이터는 숫자모양이여야 한다. (NuberFormat)

      
Test015.java
-삼각형의 밑변의 길이와 높이를 사용자로부터 입력받아
 삼각형의 넓이를 구하는 프로그램 구현

area = (double)length * height /2; //하나만 실수로 바꿔.
	//area = (double)length * height /2.0; //이게 깐지
-실수 기반의 연산을 수행해야해서 
 나눗셈 연산 : 피연산자 중 하나라도 실수면 실수기반 연산 수행!

Test016.java
-사용자로부터 이름, 국어점수, 영어점수, 수학점수를 입력받아
- 이름과 총점을 출력하는 프로그램을 구현한다.

Test017.java
- 자바의 기본 입출력 : System.int.read()
  BufferedReader의 readLine()과 비교!

System.in.read() 메소드는 한 문자만 가져온다.
readLine() 처럼 문자열대기열에 있는거 가져오는 건 같음.
단 , 입력받은 하나의 문자를 문자 그대로 가져오는 것이 아니라
ASCII Code 값으로 반환한다.
즉, 'A'를 입력하면 65로 가져온다! int형으로 변환해서 가져옴!!

-System.in.skip(매개변수);
 매개변수만큼 안읽고 건너 뛴다.
 엔터 == \r + \n

Test018.java
-printf() , format() 
-양수 강조법 : %+d
               %-d → 런타임에러 발생.
-음수 강조법 : -%d
- //System.out.printf("%d\n",'A');
		//처리가 아니라 표현이니까 아스키문자 - int 아니야
- 'A'는 char형이라 %c 해야함.
- 저렇게 쓰면 런타임 에러뜸!!
-%c 문자형, %s는 문자열형

//HEX 16진수로 바꿔서
//DEC 10진수
//OCT 8진수
//BIN 2진수
System.out.printf("%h\n", 365);
                    d
                    0
                    b
System.out.printf("%8.2f\n", 123.236);
		//  123.24
		//dot도 자리 하나
		// 앞에 두 자리
-    -    -    -    -    -    -    -
          1    2    3    .    2    4
		System.out.printf("%2.2f\n",123.236);
		//123.24 
		//쟤가 준 자리수가 우리자루에 비해 적으면
		//걍 무시깜

		System.out.printf("%3d\n",1231313);
		//1231313
		//int도 마찬가지

Test019.java
-자바의 기본 입출력 : java.util.Scaaner
※ java.util.Scanner
	 단락 문자 패턴을 사용하여 입력을 토큰에 따라 분할하며
   디폴트(default)로 사용되는 단락문자는 공백이다.
   작성된 다음 토큰은 『next()』 메소드를 사용
   다른 형태(자료형)의 값으로 변환할 수 있다.
- Scanner는 BufferedReader의 통역기(InputStreaReader)가 없어도 됨!
- IOException 없어도 됩니다. 인증받은 새끼임.

-sc.next()는 br.readLine()과 같은놈.
단, Integer.parseInt같은거 하지마.
    nextInt()가 있지롱
    별도의 형변환과정이 필요없습니다.

Test020.java
-import 안하고
- 매번 java.util.Scanner sc = new java.util.Scanner(System.in);
  가능하긴한데 할거임? 개귀찮음.

-scanner 공백 구분이 defalt임.
- 스페이스 무한해도 공백 한개로 인지
- 엔터도 공백으로 인지
- 입력값이 부족하면 당연히 안넘어가고 
- 많으면 뒤로 무시함.

Test021.java
// System.out.println("\"); -->컴파일에러
   애초에 저게 안됨. 뒤에 닫는 " 이거 써도 앵 \다음머임??
   하면서 계~속 문자열로 생각.
// 왜냐면 자바는 \이거 보고 아 ~ \s ? \d? 이러고 있음.
// 그래서 \이거 문자로 쓰고 싶으면 \\두개~
sc = new Scanner(sc.next()).useDelimiter("\\s*,\\s*");
이제 배우니까 알겠다.
sc를 초기화함. sc덮어쓰기함. 
sc = new Scanner(sc.next()).useDelimiter("\\s*,\\s*");
                            -------------
                             사용 구분자
                                         ------------
                                         모든문자열,모든문자열

→ 즉, 문자열을 콤마로 구분할게!

Test022.java
-실수형 데이터타입의 정밀도 테스트 실습
float보다 double이 정밀도가 높다. 십만번 반복했을때 값이 미세하게 다름으로 증명
→ 고로 실수는 double써라~

Test023.java
-산술 연산자
- 사용자로부터 임의의 정수를 두 번입력받아(한자리 아니여도됨)
- 사칙연산 및 나머지 연산을 수행하여 
- 그 결과를 출력하는 프로그램을 구현.
  
  문자열안에서 %를 표현하려면 "%%" 두번 쓰면 된다~!

Test024.java
- 비트 단위 연산자
  초급 개발자와 고급개발자의 차이는 비트연산자이다~
- 비트낫 == 1의 보수, 비트열반전
- 음수는 바로 2진수 계산 할 수 없다.
- 그래서 더해서 0이 되는 10진수 → 2진수로 바꾼 뒤 
   → 1의 보수를 취한뒤 + 1 을 한 값이 음수의 2진수이다.

Test025.java
- 비트and, 비트or,         비트xor
  둘다 t   둘중하나라도 t  둘이 다르면 t

Test026.java
// 비트 단위 연산자 『xor』 연산자를 활용하여
// 두 변수에 담겨잇는 내용(값) 바꾸기
x = x^y;
y = y^x;
x = x^y;

Test027.java
- shift !!! 존나 어려움.
<< 3: ← 이쪽으로 3움직여라. 뒤에는 0으로 채움
>>>3: → 이쪽으로 3움직여라. 앞에는 0으로 채움
>> 3: → 이쪽으로 3움직여라. 단, 앞에는 1로 채움 :  이거 부호변하는거방지!

Test028.java
- 논리연산자
논리and, 논리or, ! →  둘다 참, 둘 중하나 참!, 논리부정
cf ) ~ : 이건 비트부정~ 비트낫~ 1의보수 ~ 비트열반전~

Test029.java
-삼항 연산자 == 조건 연산자
 피연산자 연산자 피연산자 연산자 피연산자
 -------         --------        --------
   1항              2항             3항

  피연산자 ? 피연산자 : 피연산자
  -------    --------   --------
    1항        2항         3항

 1항의 연산 결과 → true  → 2항 수행
 		 → false → 3항 수행

Test030.java
- 사용자로부터 임의의 정수를 입력받아
  입력받은 정수가 양수인지, 음수인지, 0인지 구분하는
  프로그램 구현

Test031.java
-실행 흐름의 컨트롤(제어문)
-if ~ else
//사용자로부터 임의의 문자를 하나 입력받아
//대문자이면 소문자로 소문자이면 대문자로
//알파벳이 아닌 기타문자이면 입력오류 처리하는 프로그램을 구현

-boolean은 자동형변환 대상이 아닙니다. 
 그래서 명시적형변환도 안됩니다!

Test032.java
-사용자로부터 임의의 연도를 입력받아
 윤년인지 평년인지 판별하여
 결과를 출력하는 프로그램을 구현하라.

- 윤년 조건
  4의 배수이고 100의 배수가 아니다
  혹은 400의 배수이면 윤년이다.

Test033.java
//1. 프로그램을 작성할 때 주어진 조건에 따라
//   분기 방향을 정하기 위해 사용하는 제어문에는
//   if문, if~else문, 조건연산자, 복합if문(if문 중첩),
//   switch 문이 있다.

//2. if문은 if 다음의 조건이 참일 경우,
//   특정 문장을 수행하고자 할 때 사용되는 구문이다.

Test034.java
-if ~ else 실습

Test035.java
-if ~ else 실습, 홀수,짝수,0
-else에서 result를 출력할 때, 초기화를 하지않으면
 자바는 영짝홀 아닐 때, result가 뭔데~ 해서 컴파일에러발생!
// ※ if ~ else 구문의 중첩 구문은
//	  반드시 else로 끝나야 하는 것이 아니다.
//	  다만, 출력해야 할 구문을 처리하는 과정에서
//	  문제가 발생하지 않는 구문으로 작성해야 한다.


// ※ 조건문 구성 과정에서 이외의 영역(else)을
//    업무에 포함된 내용으로 처리하는 것은 바람직하지 않을 경우가 있다.
//    불가능한 경우는 어쩔 수 없더라도
//    가급적이면 업무에 포함되지 않는 내용을
//    이외의 영역(else)에서 처리할 수 있도록 하자.
// ex)주민번호, 010 등

Test036.java
-if ~ else 실습
// 사용자로부터 임의의 정수를 입력받아
// 다음과 같은 판별 결과를 출력하는 프로그램을 구현한다.

// 2의 배수 / 3의 배수 / 2와 3의 배수 / 2와 3의 배수 아님

Test037.java	과제
-if ~ else 실습
//사용자로부터 임의의 연도를 입력받아
//입력받은 연도가... 윤년인지 평년인지 판별하여
//그 결과를 출력하는 프로그램을 구현한다.
//단, 입력은 BufferedReader의 readLine()을 활용하고
//if 조건문을 활용하여 연산을 수행할 수 있도록 한다.

Test038.java
//사용자로부터 임의의 두 정수와 연산자를 입력받아
// 해당 연산자의 연산 처리 결과를 출력하는 프로그램을 구현해라.
// 단, if 조건문을 활용하여 처리할 수 있도록 하며,
// 연산 결과는 편의상 정수 기반으로 처리될 수 있도록 한다.

// 실행 예 )
// 첫 번째 정수 입력 : 
// 두 번째 정수 입력 : 
// 연산자 입력 [+ - * /] :

Test039.java
// 사용자로부터 임의의 정수 세개를 입력받아
// 작은 수에서 큰 수 순으로 출력하는 프로그램을 구현한다.

// 실행 예)
// 첫 번째 정수 입력 : 7
// 두 번째 정수 입력 : 70
// 세 번째 정수 입력 : 42

// >> 정렬 결과 : 7 42 70
// 계속하려면 아무 키나 누르세요 .....
// (1) 첫 번째 vs 두 번째
//		→ 첫 번째 정수 > 두 번째 정수보다 클 경우 자리 바꿈.
// (2) 첫 번째 vs 세 번째
//		→ 첫 번째 정수 > 세 번째 정수보다 클 경우 자리 바꿈
// (3) 두 번째 vs 세 번째
//		→ 두 번째 정수 > 세 번째 정수보다 클 경우 자리 바꿈.

- 나중에 쓴건데 max라는 변수에 담아서 실행하는 법도 있다.

Test040.java
// 사용자로부터 임의의 정수 5개를 입력받아
// 짝수별, 홀수별 합계를 출력하는 프로그램을 구현한다.
// 단, Scanner를 활용하여 데이터를 입력받을 수 있도록 한다.

// 실행 예 )
// 임의의 정수 5개 입력 : 1 2 3 4 5

// >> 짝수의 합은 6이고, 홀수의 합은 9 입니다.
// 계속하려면 아무 키나....

-누적합은 초기화 0부터
-누적곱은 초기화 1부터!

Test041.java	과제
-if ~ else 실습
//if ~else 

//  사용자로부터 임의의 알파벳 한 문자를 입력받아
//  이를 판별하여 입력받은 알파벳이 모음일 경우만
//  결과를 출력하는 프로그램을 구현한다.
//  단, 대소문자를 모두 적용할 수 있도록 처리한다.
//  또한, 알파벳 이외의 문자가 입력되었을 경우
// 입력 오류에 대한 내용을 사용자에게 안내해 줄 수 있도록 한다.

// 실행 예 )
// 임의의 알파벳 한 문자 입력 : A
// >> 모음 OK ~!!!
// 계속하려면 아무 키나...

// 임의의 알파벳 한 문자 입력 : e
// >> 모음 OK ~!!!
// 계속하려면 아무 키나...

// 임의의 알파벳 한 문자 입력 : B
// 계속하려면 아무 키나...

// 임의의 알파벳 한 문자 입력 : 1
// >> 입력 오류 ~!!!
// 계속하려면 아무 키나...

Test042.java	과제
//사용자로부터 임의의 문자를 하나 입력받아
//대문자이면 소문자로 소문자이면 대문자로
//알파벳이 아닌 기타문자이면 입력오류 처리하는 프로그램을 구현한다.


// 실행 예)
// 한 문자 입력 : A
// A → a
//계속하려면 아무 키나 누르세요....


// 한 문자 입력 : b
// b → B
//계속하려면 아무 키나 누르세요....

// 한 문자 입력 : 7
// >> 입력 오류 ~!!!
//계속하려면 아무 키나 누르세요....

Test043.java
-switch 실습
// switch 문 실습

/*
○ 다중 선택문이라 하며. switch 문 다음의 수식 값에
   따라 실행 순서를 여러 방향으로 분기할 때 사용하는
   문장이다.

○ 형식 및 구조
   switch(수식)
   {
	   case 상수1 : 문장1; [break;]		break 멈추고 (빠져나간다.)
	   									continue (뒷부분 무시하고) 계속해라
	   case 상수2 : 문장2; [break;]
	       :              :
	   [default : 문장n+1; [break;]]		//[]는 생략가능!
	}										//if문에 else랑 비슷
											//반드시 디폴트 ㄴㄴ
											//처리영역에서는 가능
											// 출력에서 에러날수는 있음.

	switch 문의 『수식』과 case의 『상수』는
	byte, short, int, long 형이어야 한다.
	//정수형태의 프리미티브형식만

	case 문 뒤에 『break;』가 없는 형태인 경우
	다음 case 문의 문장을 계속해서(이어서) 수행하게 된다. → (기본모델)
	『break;』가 존재할 경우
	해당 지점에서 수행을 멈춘 후 switch 문을 빠져나간다. → (일반모델)

Test044.java
-switch 실습
// 사용자로부터 1부터 3까지의 정수 중 하나를 입력받아
// 입력받은 정수만큼의 별문자(★)가 출력되는 프로그램을 작성한다.
// 단, 두 가지 방법으로 구현할 수 있도록 한다.

//① switch 문의 일반 모델을 사용한다.
//② switch 문의 기본 모델을 사용하되,
//   『break』를 딱 한 번만 사용할 수 있도록 구성한다.

// 실행 예)
// 임의의 정수 입력(1~3) : 3
// ★★★
// 계속하려면 아무 키나...

// 임의의 정수 입력(1~3) : 1
// ★ 
// 계속하려면 아무 키나...

// 임의의 정수 입력(1~3) : 7
// 입력 오류 ~ !!
// 계속하려면 아무 키나...

-누적을 이용하자!

Test045.java
// 사용자로부터 임의의 두 정수와 연산자를 입력받아
// 해당 연산자의 처리 결과를 출력하는 프로그램을 구현하라.
// 단, switch 문을 활용하여 처리할 수 있도록 하며
// 연산 결과는 편의상 정수 형태로 처리할 수 있도록 한다.

// 실행 예)
// 첫 번째 정수 입력 : 3
// 두 번째 정수 입력 : 17
// 연산자 입력 [+ - * /] : -

// >> 3 - 17 = -14
// 계속 ..............

Test046.java
- 반복문 실습
○ 반복문의 개요
	
	주어진 조건이 『참』인 경우
	일정한 영역의 문장을 반복 수행하다가
	조건식이 거짓이 되는 순간이 오면,
	반복 수행을 중단하는 문장이다.
	이러한 반복문에는 『while』, 『do ~ while』,『for』문 등이 있으며
	반복문의 제어를 위해 『break』,『continue』문을
	사용하는 경우가 있다.

○ while 문

	조건식을 먼저 비교하여
	조건식의 처리 결과가 참인 경우, 특정 영역을 반복 수행하는 문장으로
	반복 횟수가 정해져 있지 않은 경우나
	반복 횟수가 많은 경우 주로 사용한다.
	while 문은 조건이 맞지 않은 경우
	반복은 커녕 단 한 번도 실행되지 않을 수 있다.

○ while 문의 형식 및 구조

	while(조건식)
	{
		실행문;
	}
☆ 문제 1부터 100까지의 합을 계산하여
   결과 출력하는 프로그램을 구현한다.
   단 , while 반복문을 사용한다.

   실행 예 )
   1부터 100까지의 합: 5050
   계속하려면 아무 키나.......

※ 문제 인식 및 분석
	1. 출력 구문이 반복문의 영역 밖에 위치해야 한다.
	2. 1부터 1씩 증가할 변수와 누적합을 담을 변수
	   두 개의 변수가 필요하다.

Test047.java
-반복문(while)실습
//1부터 100까지의 정수 중에서 
//짝수들의 합을 계산하여 결과값을 출력하는 프로그램을 구현하라.
// 단, 조건문을 사용하지 않도록 하며,
// while 반복문을 활용하여 작성할 수 있도록 한다.

// 실행 예)
// 1부터 100까지의 정수 중 짝수의 합 : xxxx
// 계속 .........


//※ 문제 인식 및 분석
// 2+ 4+ 6+ 8 + ... + 100
//	- 초기값 : 2
//	- 증가값 : 2
//  - 한계값 : 100

Test048.java
-반복문(while)실습
//1부터 100까지의 정수 중에서
//짝수들의 합과 홀수들의 합을 따로 구분하여 계산한다.
// 단, 반복문은 while 문을 사용할 수 있도록 하며,
// 조건 구문은 if 조건문을 사용하여 작성할 수 있도록 한다.

// 실행 예 )
// 1부터 100까지의 정수 중
// 짝수의 합 : 2550
// 홀수의 합 : 2550
//계속 ............

Test049.java
-반복문(while)실습
//실행 예 )
// 1 부터 100 까지 정수의 합은 : 5050
// 1 부터 100 까지 짝수의 합은 : 2550
// 1 부터 100 까지 홀수의 합은 : 2500
//계속 ............

Test50.java
-반복문(while)실습
//1부터 100까지 정수의 합을 구하되,
//10의 배수가 될 때 마다... 결과를 출력하는 프로그램을 구현하라.

// 실행 예 )
// 1~10 까지의 합:
// 1~20 까지의 합:
// 1~30 까지의 합:
//	    :	
//1~100까지의 합 : 
//계속 .............

Test051.java
-반복문(while)실습
-n/n+1 + n+1/n+2 + ... + n+8 / n+9 의 연산 처리 결과를 출력하는 프로그램을 구현.

Test052.java
//반복문(while 문) 실습
//1 * 2 * 3 * ...* 9 * 10
-누적곱은 1로 초기화.

Test053.java
-반복문(while)실습
//사용자로부터 임의의 정수를 입력받아
//입력받은 정수가 소수인지 아닌지를 판별하여
//결과를 출력하는 프로그램을 구현한다.
※ 소수 : 1 또는 자기 자신의 값 이외에 어떤 수로도 나누어 떨어지지 않는 수.
//		     단, 1 은 소수 아님.

Test054.java

-반복문(while)실습
// 사용자로부터 임의의 두 정수를 입력받아
// 작은 수부터 큰 수 까지의 합을 구하여
// 결과를 출력하는 프로그램을 구현한다.

// 실행 예)
// 첫 번째 정수 입력 : 10
// 두 번째 정수 입력 : 20 
// >> 10 ~ 20 까지의 합은 : xxxx
// 계속하려면 ........

// 첫 번째 정수 입력 : 10
// 두 번째 정수 입력 : 2 
// >> 2 ~ 10 까지의 합은 : xxxx
// 계속하려면 ........

Test055.java	과제
-반복문(while)실습
//   사용자로부터 임의의 정수를 입력받아
//   1부터 입력받은 그 정수까지의
//   전체 합과, 짝수의 합과 , 홀수의 합을 
//   각각 결과값으로 출력하는 프로그램을 구현한다.


Test056.java
-반복문(while)실습
//사용자로부터 원하는 단(구구단)을 입력받아
//해당하는 구구단을 출력하는 프로그램을 구현한다.
// 단, 1단 ~ 9단 사이의 수를 입력받은 상황이 아니라면
// 이에 대한 안내를 한 후 프로그램을 종료할 수 있도록 처리한다.
//실행 예 )
//원하는 단(구구단) 입력 : 7
//7 * 1 = 7
//7 * 2 = 14
//7 * 3 = 21
//    :
//7 * 9 = 63
//계속하려면 아무 키나 .......

//원하는 단(구구단) 입력 : 11
//1부터 9까지의 정수만 입력이 가능합니다.
//계속하려면 아무 키나 .......
return; → 프로그램 종료, main()함수 종료.


Test057.java
-반복문(do ~ while)실습
○ 개요
	『do ~ while』문은 『while』문과 마찬가지로
	특정한 영역을 반복 수행하는 반복문이다.
	다만 『while』문과 다른 점은
	조건식에 대한 검사를 반복문을 수행한 이후에 한다는 것이다.
	이와 같은 성격으로 인해 반드시 한 번은 수행하게 되는 특징을 갖는다.

○ 형식 및 구조
  
	do 
	{
		실행문;
	}
	while(조건식);

// do ~ while 문의 활용 모델
// 예를 들어... 사용자로부터 특정 범위의 정수가 입력될 때 까지
// 입력받은 행위 자체를 반복해서 수행해야 하는 상황이라 가정한다.

//즉, 최소 한 번은 사용자의 입력값을 받아오는 처리를 수행해야
//반복을 추가로 수행할지 말지의 여부를 결정할 수 있는 상황이다.


Test058.java


-반복문(do ~ while 문) 실습

// 사용자로부터 여러 개의 양의 정수를 입력받고,
// 그 합을 계산하여 출력하는 프로그램을 작성한다.

// 단, -1이 입력되는 순간
// 입력을 중지하고 그동안 입력된 정수의 합을 출력해주는 프로그램을 구현한다.
// 즉, 『-1』을 입력 중지 커맨드로 활용한다.
// do ~ while 문을 활용하여 문제를 해결할 수 있도록 한다.



// 실행 예 )
// 정수1 입력 : 10
// 정수2 입력 : 5
// 정수3 입력 : 8
// 정수4 입력 : 9
// 정수5 입력 : -1

// >> 현재까지 입력된 정수의 합 : xxxx
// 계속하려면 .............

Test059.java
-반복문(do ~ while 문) 실습

○ 개요

    『for』문은 정해진 횟수만큼 반복해야 하는 경우
	유용하게 사용되어지는 반복문으로
	『while』문과 마찬가지로 반복 실행해야 하는 구문이
	조건에 맞지 않을 경우 한 번도 수행하지 않을 수 있으며
	루프 변수의 초기값, 조건식, 증감식 등을 한 지점에서 확인할 수 있기 때문에
	가독성이 높은 반복문에 해당한다.

○ 형식 및 구조
	
	for (수식1; 수식2; 수식3)
	{
		실행문;
	}

	수식1은 루프 변수의 초기화를 위해 사용되며,
		    최초 단 한번만 실행된다.
	수식2는 조건식을 나타내는 것으로 이 조건식(수식2)이 만족하면
	        루프를 반복해서 수행하게 된다.
			『for』문의 진행 순서는 수식2가 참이면 반복문을 수행하고
			수식3을 실행한 후 수식2의 조건식을 다시 검사하는 구조로 진행된다.
			따라서 처음에 조건식의 처리 결과가 거짓일 경우
			『for』루프를 한 번도 수행하지 않게 되는 것이다.
	수식3은 루프 변수의 재초기화를 위해 사용되어지며,
		    반복문의 조건식을 무너뜨리게 되는 증감식으로 처리하는 것이 일반적이다.
			컴마(『,』를 이용하여 여러 문장을 동시에 수행할 수도 있다.

수식2를 제외하고는 콤마가 사용가능하다!


Test060.java

-반복문(for 문) 실습


//1부터 100까지의 정수 중에서
//4의 배수만 출력하는 프로그램을 구현한다.
//단 for문을 활용해야 하며
//한 줄에 5개씩만 출력할 수 있도록 한다.


//실행 예 )
// 4	8	12	16	20
//24	28	32	36	40
//			:
//			:
//계속하려면 아무 키나 누르세요.....



Test061.java
-반복문(for 문) 실습

//다중 for문(반복문의 중첩)을 활용한 구구단 출력 실습

//실행 예)
/*
[2단]
2 * 1 = 2
2 * 2 =4
	:
2 * 9 = 18

[3단]
  :
9 * 9 = 81
// 계속하려면..........
*/

Test062.java
-반복문(for 문) 실습
//다중 for문(반복문의 중첩)을 활용한 구구단 출력 실습

//① 2중첩 *2		//②3중첩 *1


// 실행 예)
/*

2 * 1 = 2               3 * 1 = 3               4 * 1 = 4               5 * 1 = 5
2 * 2 = 4               3 * 2 = 6               4 * 2 = 8               5 * 2 = 10
2 * 3 = 6               3 * 3 = 9               4 * 3 = 12              5 * 3 = 15
2 * 4 = 8               3 * 4 = 12              4 * 4 = 16              5 * 4 = 20
2 * 5 = 10              3 * 5 = 15              4 * 5 = 20              5 * 5 = 25				→→→ 1문단
2 * 6 = 12              3 * 6 = 18              4 * 6 = 24              5 * 6 = 30
2 * 7 = 14              3 * 7 = 21              4 * 7 = 28              5 * 7 = 35
2 * 8 = 16              3 * 8 = 24              4 * 8 = 32              5 * 8 = 40
2 * 9 = 18              3 * 9 = 27              4 * 9 = 36              5 * 9 = 45

6 * 1 = 6               7 * 1 = 7               8 * 1 = 8               9 * 1 = 9
6 * 2 = 12              7 * 2 = 14              8 * 2 = 16              9 * 2 = 18
6 * 3 = 18              7 * 3 = 21              8 * 3 = 24              9 * 3 = 27
6 * 4 = 24              7 * 4 = 28              8 * 4 = 32              9 * 4 = 36
6 * 5 = 30              7 * 5 = 35              8 * 5 = 40              9 * 5 = 45				→→→ 2문단
6 * 6 = 36              7 * 6 = 42              8 * 6 = 48              9 * 6 = 54
6 * 7 = 42              7 * 7 = 49              8 * 7 = 56              9 * 7 = 63
6 * 8 = 48              7 * 8 = 56              8 * 8 = 64              9 * 8 = 72
6 * 9 = 54              7 * 9 = 63              8 * 9 = 72              9 * 9 = 81
계속하려면 아무 키나 누르십시오 . . .

//1. Test061과 비교하여
//출력의 방향이 다르기 때문에
//반복문의 제어 흐름도 달라져야 한다.
//콘솔기반의 출력환경이기 때문에..

//2.(1)에따라
//단과 곱해지는 수의 위치가
//달라진 상태에서 반복문 구성

//3.(2)에서 처리한 결과를 
//두 문단으로 반복하는 반복문 구성
//check~!!!! 반복문에 2의 결과를 삽입

//4.같은 구문을 
//두 문단으로 나누어 처리하는 과정에서
//문단에 따라 주어진 환경 (h의 값)을 활용하는 방법으로
//최종 반복문 3중첩.

Test063.java	과제
-반복문(for 문) 실습
//◎ 과제
//   다음과 같은 내용이 출력될 수 있도록
//   반복문의 중첩 구문을 작성하여 프로그램을 구현한다.

/* 실행 예)
    *	→ 공백 4 별 1    
   **   → 공백 3 별 2
  ***   
 ****
*****
*/

Test064.java	과제
-반복문(for 문) 실습
//다중 for문(반복문의 중첩)을 활용한 별찍기 실습

//◎ 과제
//   다음과 같은 내용이 출력될 수 있도록
//   반복문의 중첩 구문을 작성하여 프로그램을 구현한다.

/* 실행 예)  

    *
   ***
  *****
 *******
*********
*/

Test065.java	과제
-반복문(for 문) 실습
//다중 for문(반복문의 중첩)을 활용한 별찍기 실습

//◎ 과제
//   다음과 같은 내용이 출력될 수 있도록
//   반복문의 중첩 구문을 작성하여 프로그램을 구현한다.

/* 실행 예)

*********
 *******
  *****
   ***
    *
*/

Test066.java	과제
-반복문(for 문) 실습
//다중 for문(반복문의 중첩)을 활용한 별찍기 실습

//◎ 과제
//   다음과 같은 내용이 출력될 수 있도록
//   반복문의 중첩 구문을 작성하여 프로그램을 구현한다.

/* 실행 예)

    *   
   ***  
  ***** 
 *******
*********
 *******
  ***** 
   ***  
    *   
*/

Test067.java
-break 실습
// 다음과 같은 처리가 이루어지는 프로그램을 구현한다.
// 단, 입력받는 정수는 1 ~100 범위 안에서만
// 가능하도록 작성한다.

// 실행 예)
// 임의의 정수 입력 : -10

// 임의의 정수 입력 : 0

// 임의의 정수 입력 : 2022

// 임의의 정수 입력 : 10
// >> 1 ~ 10 까지의 합 : 55
// 계속하시겠습니까?(Y/N)? : y

// 임의의 정수 입력 : 100
// >> 1 ~ 100 까지의 합 : 5050
// 계속하시겠습니까?(Y/N) : N
// 계속하려면 아무 키나 누르세요 ... → 프로그램 종료.
br.reaLine()은 문자열을 받아옴! 
System.in.read()는 아스키코드를 받아옴!! 
엔터 = \r + \n입니다.
System.in.skip(2); : 대기열 엔터 스킵!!
※ break
반복문 멈추고 빠져 나가라 ~ 
가장 가까운 반복문을 빠져나간다!!
cf) continue
뒷 부분 무시하고 계속해라~~ 
→ 얘는 반복문의 처음으로 돌아갑니다! 반복문을 끝낼 수가 없어요 ~!!


Test068.java
-continue 실습

//continue 를 활용하여
// 다음과 같이 출력될 수 있도록 프로그램을 구현한다.
// 실행 예)

/*
1 : 1
3 : 4
5 : 9
7 : 16
  :
  :
  :
99: 2500
계속하려면 아무 키나 누르세요....

Test069.java
-return 실습

// ※ return 키워드가 지니는 두 가지 의미
//    ① 『값의 반환.』 return을 포함하고 있는 메소드에서 
//       지점에 값을 두고 온다..
//		  return + 무엇을 → 이런 형식


//    ② 『메소드 종료.』 return을 포함하고 있는 메소드 종료.
//        지금은 main()만 정의 중 → 프로그램 종료.
//        return; 단일.

Test070.java
-지역변수와 전역변수
// 지역 변수의 초기화 테스트

//Test071.java와 비교
// ※ 지역 변수는 초기화 과정을 거치지 않으면 사용할 수 없다.
//    자바가 자동으로 초기화를 수행해 주거나 하지 않는다.

//클래스의 영역에서 선언한 변수 == 전역 변수 == 글로벌변수
	// 클래스 변수 != 전역 변수
	// 클래스 변수 따로 있음
	public static void main(String[] args)
	{
		//메소드의 영역에서 선언한 변수 == 지역 변수 == 로컬변수
		int n;
		// --선언 후 초기화 과정을 거치지 않은 상태.
		System.out.println("n + : " + n);
		// → 컴파일 에러 발생
		//variable n might not have been initialized
		// → 지역 변수 n에 접근하여 그 값을 출력하고자 하는 구문



Test071.java
-전역 변수의 초기화 테스트
-전역변수는 클래스의 영역에서 선언됨.
- 인스턴스 생성해서 메모리에 올라감.
-자바가 자동으로 0으로 초기화합니다. 메모리에 올리면서 자동으로 설정.
- 자바는 메모리에 직접적인 접근을 허용하지 않는다.

Test072.java
-클래스와 인스턴스
// 직사각형 클래스 설계 실습

/*
직사각형의 넓이와 둘레 계산 → 클래스 표현

클래스의 정체성 → 직사각형
클래스의 속성   → 『가로,세로』, 넓이, 둘레, 부피, 무게, 재질, 색깔... 등
클래스의 기능   → 넓이 계산, 둘레 계산, 가로세로 입력, 결과 출력...등



객체를 구성     → 데이터(속성, 상태) + 기능(동작, 행위)
	↓
클래스를 설계   →		 변수         +      메소드

클래스 만들기 단계
① 변수 뭐하지?
② 메소드 뭐하지?
③ 메소드 매개변수 뭐하지?

클래스 설계도를 작성하면 인스턴스 생성을 먼저해야함

인스턴스 변수, 인스턴스 생성될 때, 메모리  할당받아요
멤버변수 == 전역변수 == 인스턴스 변수

반환자료형(반환되는 곳에 : 호출한 곳에 두고올거) 메소드명()
{
}
void는 출력만 합니다. 그 위치에 문자열 두고 오는게 아님.
// ※ 하나의 자바 파일 (.java)에 여러 개의 클래스(class)를 설계 할 수 있나???
// 	  : Yes
//    ★하지만, 『public class』는 하나만 올 수 있다.★
//    main()이 없는 java파일도 있다~
// 일반적으로는 하나의 파일에 하나의 클래스를 설계한다.
// 또한, 여러 개의 클래스가 설계된 파일을 컴파일하게 되면
// ★내부에 설계된 클래스의 수 만큼 클래스 파일(.class)이 파생된다.★

객체를 생성해야 메모리에 할당이 됩니다.

Test073.java
//※ CircleTest.java 파일과 세트 ~!!

// 원의 넓이와 둘레 구하기
// 원의 넓이와 둘레를 구할 수 있는 클래스를 설계한다.
// (클래스명 : CircleTest) → CircleTest.java
// BufferedReader의 readLine() 활용.

// 원의 넓이 = 반지름 * 반지름 * 3.141592
// 원의 둘레 = 반지름 * 2 * 3.141592

// 실행 예)
// 반지름 입력 : xx


// >> 반지름이 xx인 원의
// >> 넓이 : xx.xx
// >> 둘레 : xx.xx
// 계속하려면 아무 키나 누르세요....
import java.io.IOException;
//인스턴스 생성할때, import가 필요없는 이유는????????
// ▶▶▶▶▶▶▶▶ 물리적으로 같은 디렉토리안에 있어서

??? 클래스 기반 인스턴스 생성
??? 인스턴스 생성
??? 객체 생성

Test074.java

// 사용자로부터 임의의 정수를 입력받아
// 1 부터 입력받은 수 까지의 합을 연산하여
// 결과값을 출력하는 프로그램을 구현한다.

//단, 클래스와 인스턴스의 개념을 활용하여 처리할 수 있도록 한다.
// 또한, 입력 처리 과정에서 BufferedReader의 readLine()을 사용하며,
// 입력 데이터가 1보다 작거나 1000보다 큰 경우
// 다시 입력 받을 수 있는 처리를 포함하여 프로그램을 구현할 수 있도록 한다.

//실행 예)
//임의의 정수 입력 (1~1000) : 1050
//임의의 정수 입력 (1~1000) : -45
//임의의 정수 입력 (1~1000) : 100
// >> 1 ~ 100 까지의 합 : 5050
// 계속하려면 ............

생성한 인스턴스를 통해 입력 메소드 호출 
 : 참조변수 활용

Test075.java
// 사용자로부터 임의의 두 정수와 연산자를 입력받아
// 해당 연산을 수행하는 프로그램을 구현한다.
// 단, 클래스와 인스턴스의 개념을 활용하여 작성할 수 있도록 한다.

// 실행 예)
// 임의의 두 정수 입력 (공백 구분) : 10 5
// 임의의 연산자 입력 ( + - * /) : +
// >> 10 + 5 = 15
switch문에서 default : 경우의 수가 없으면 디폴트값..

Test076.java
-생성자(Constructor)

○ 생성자(Constructor)의 역할
 
   1. 인스턴스 생성 → 메모리 할당
   2. 초기화

○ 생성자(Constructor)의 특징

   1. 생성자는 메소드이지만, 일반 메소드처럼 호출될 수 없으며,
   							_______________
							자주 호출 불가
      반환 자료형을 가질 수 없다.
	  (『void』 조차 가질 수 없으며, 값을 반환할 수도 없다.)
	  return 있으면 안된다.

	2. 생성자는 클래스와 동일한 이름을 가져야 한다.
	   (대소문자 명확히 구분)
	
	3. 생성자는 객체를 생성하는 과정에서 『new생성자();』의 형태로 호출한다.
	   (인스턴스 생성 시 단 한 번만 호출)
	   __________________________________
	   이러한 특징 때문에 final 변수 초기화가 가능하다.

/*				 // ★ 사용자 정의 생성자가 존재하지 않을 경우
	NumberTest() // -- 컴파일 과정에서 자동으로 삽입되는 『디폴트 생성자』
				 //    (default Constructor)
				 //    클래스 이름과 같은 메소드를 만들어 주고
				 //    텅 비어있는 상태, 매개변수 없는 메소드.
				 //    눈에 보이지는 않지만.

전역변수는 자바가 0으로 초기화 해줌.
별도로 생성자 만들었다면 디폴트 생성자가 만들어지지 않는다.

Test077.java
-생성자(Constructor)
-사용자 정의 생성자가 있으면 디폴트 생성자가 자동으로 생성되지 않는다.
-사용자 정의 생성자에 매개변수가 필요하면
 생성자 () ← 이거 안에 매개변수 넣어야 컴파일 에러가 안뜬다!

Test078.java
-생성자(Constructor)
- 클래스에서 선언된 변수 멤버 변수, 인스턴스 변수 (static변수, 클래스 변수랑 다름)
	// 동일한 스코프안에서 동일한 메소드는 정의 안돼
	// 메소드가 식별가능해야하기 때문에.!

	// ※ 생성자의 이름은 항상 예외없이 클래스의 이름과 동일해야 하며
	//    필요할 경우 인수를 받아들이는 것도 가능하고
	//    같은 이름의 메소드를 정의하는 중복정의가 가능하지만
		→ 생성자 오버로딩이 가능하다.
                   생성자는 클래스안에서 최소 한개!
		   한 클래스는 반드시 하나 이상의 생성자를 가진다.
	//    리턴값 (반환값)은 가질 수 없다.


	// ※ 생성자는 다른 일반 메소드처럼 호출될 수 없고,
	//	  『new』 연산자를 이용하여 객체를 생성하기 위해 호출되며,
	//     각 클래스의 인스턴스인 객체를 생성한 후에
	//     생성된 객체의 멤버를 초기화시키는 작업을 수행한다.
인스턴스 생성 구문이 아닌데 
클래스 이름을 쓴다? → 고민해라. 
같은 클래스면 this를 써라. 클래스명을 대놓고 쓰지마라.
this가 쓰이면 이게 포함된 클래스를 찾아라.
this == class 명.

※ 생성자 안에서 생성자 호출이 가능할까요?

네. 가능합니다.
생성자 내부에서 다른 생성자를 호출하는 것은 가능하다.
하지만, 생성자 내부에서 가장 먼저 실행되어야 한다.!
이유랑 제한사항 꼭 기억해!
이유 : 다른생성자호출(100)이 일벌린걸 남은 걸로 해결하기 위해
제한사항 : 위쪽에. 먼저!!!

Test079.java
-생성자(Constructor)
-멤버변수는 초기화를 안해도 자바가 0으로 초기화 합니다!
-생성자 오버로딩

Test080.java
-생성자(Constructor)와 초기화 블럭(Initialized Block)
-멤버변수 선언하고 초기화 따로
int n;
n = 100;  → 불가합니다  error: <identifier> expected
             『=』는 대입연산자 입니다. 대입연산자? 오른쪽부터
    	     대입 연산자도 연산입니다 . 연산처리는 클래스안에서 ㄴㄴ
             메소드!!안에서만 가능!! 아무래도 상수에 대한 메모리할당이
	     안돼. 클래스가 객체생성전에는 메모리 할당이 안돼서 그런듯?

int n = 100; 이건 가능해요 선언과 동시에 초기화!

초기화 블럭(Initialized Block) 이란?
클래스안에서 멤버변수 선언하고 
{
	이 안에서 멤버변수를 초기화 할 수 있습니다!
}

생성자 vs 초기화블럭
초기화 블럭이 코드를 먼저 수행했다하더라도
최종적으로는 해당 멤버들의 초기화 값은 생성자가 결정.
초기화 블럭 실행 → 생성자 실행
초기화가 무슨 짓을 해도 생성자가 덮어씀!!!!!!!!!!!
생성자 내부에서 생성자를 호출하는 것두 같은 방법.
생성자 내부에서 생성자 호출하면 제일 먼저!!!!!!!!!!!!!!
             
Test081.java
-배열 선언과 초기화
○ 배열의 개요
   
   1. 배열이란?
      크기와 성격이 같은 일련의 원소들이 모여
	  공동의 집합 구조를 갖는 자료의 집합체를 의미하는 것으로
	  『동질적인 성격을 가진 자료들』에 대해
	  개별적으로 자료형(Data type)을 부여하지 않고
	  하나의 이름을 가지고 일괄적으로 처리할 목적으로 사용된다.

   2. 자바에서의 배열은 다음과 같은 순서에 의해 사용된다.
      배열 선언 → 배열에 메모리 할당 → 배열 요소 접근(배열 요소의 사용)


○ 형식 및 구조
   
   자료형[] 변수명; //[]생략가능 ㄴㄴ 문법적으로 쓰임.
   변수명 = new 자료형[요소크기]
   변수명[인덱스] = 값;

   int[] arr; == int a[]; (같음.)
   arr = new int[3];
   int [] arr == new int[3]; 
					// 인스턴스 생성이랑 비슷하게 생겼으니 헷갈 ㄴㄴ
					// 배열도 참조타입임. 주소가 담겨있음.

// 배열은 다음과 같이 선언과 동시에
		// 메모리 할당 및 초기화가 가능하다.
		int [] arr2 = new int[10];
		int [] arr3 = {1,2,3,4,5,6,7,8,9,0};
		int arr4 [] = {1,2,3,4,5,6,7,8,9,0};
//※ 값을 할당하지 않은 나머지 배열 공간은
		//   자동으로 초기화된다 → 0 (int형 배열)
int num = 10;
		System.out.println("num : " + num);
		// -- >> num : 10

		System.out.println("arr : " + arr);
		// -- >> arr : [I@15db9742
		//       메모리의 주소값을 의미하는 건 아님.
		//       배열을 출력하기 위해 배열변수를 일반 변수처럼 사용하여
		//       배열의 각 방에 들어있는 데이터가 출력되는 것이 아니라
		//       우리가 알아볼 수 없는 코드가 출력된다.
		//       (자바는 메모리 주소값에 사용자가 직접 접근하는 것을 허용하지 않기 때문에)

변수는 변수값이 그대로 담겨있고 배열은 참조주소가 담겨있다!
그래서 배열 값에 접근하려면 arr[0]이런식! 인덱스번호를 줘라!

Test082.java
// 배열의 기본적 활용

// 임의의 정수들이 들어있는 배열의 숫자 데이터들 중
// 짝수인 요소만 골라서 출력하고, 3의 배수인 요소만 골라서 출력하는
// 프로그램을 구현한다.
배열의 길이(방 갯수) 확인 : arr.length
arr의 변수임. 

Test083.java
// 배열의 선언과 초기화
// 배열의 기본적 활용

// 『char』 자료형의 배열을 만들어
// 그 배열의 각 방에 알파벳 대문자를 채우고
// 채워진 그 배열의 전체 요소를 출력하는 프로그램을 구현한다.
// 단, 채우는 구문과 출력하는 구문은 따로 분리하여 처리한다.

// 실행 예 )
// A B C D E F G H I ... W X Y Z
// 계속하려면 아무 키나 누르세요...
★반복문 안에 변수 1개아님!!
for(수식1;수식2;수식3)이면
수식1, 수식3에는 변수 여러개 가능합니다!

Test084.java
-배열의 선언과 초기화
// 배열의 기본적 활용

// 사용자로부터 인원수를 입력 받고
// 입력받은 인원 수 만큼의 학생 이름과 전화번호를 입력받고
// 이를 이름 배열과 전화번호 배열로 구성하여 
// 결과를 출력할 수 있는 프로그램을 구현한다.

// 실행 예)
// 입력 처리할 학생 수 입력(명, 1 ~ 10) : 27
// 입력 처리할 학생 수 입력(명, 1 ~ 10) : -5
// 입력 처리할 학생 수 입력(명, 1 ~ 10) : 3
// 이름 전화번호 입력[1](공백 구분) : 박현수 010-1111-1111
// 이름 전화번호 입력[2](공백 구분) : 신시은 010-2222-2222
// 이름 전화번호 입력[3](공백 구분) : 오이삭 010-3333-3333

//---------------------------------
// 전체 학생 수 : 3명
//---------------------------------
//이름		       전화번호
//박현수	       010-1111-1111
//신시은		   010-2222-2222
//오이삭		   010-3333-3333
//---------------------------------
//계속하려면 ................

do ~ while문에서
while문이 true면 반복혀라!!

Test085.java	과제
-배열의 기본적 활용

//   사용자로부터 임의의 정수를 임의의 갯수만큼 입력받아
//   입력받은 수 중에서 가장 큰 수를 출력하는 프로그램을 작성한다.
//   단, 배열을 활용하여 구현할 수 있도록 한다.

// 실행 예)
// 입력할 데이터의 갯수 : 12
// 데이터 입력 (공백 구분) : 74 65 13 91 5 67 33 41 2 50 11 38
// >> 가장 큰 수 → 91
// 계속하려면 아무 키나 누르세요...
가장 큰 수 구하기!
max변수를 arr[0]으로 주고 크기비교해서 max를 초기화해라!


Test086.java	과제
-배열의 기본적 활용

//   사용자로부터 임의의 학생 수를 입력받고
//   그만큼의 점수(정수 형태)를 입력받아
//   전체 학생 점수이 합, 평균, 편차를 구하여
//   결과를 출력하는 프로그램을 구현한다.
//   단, 배열을 활용하여 처리할 수 있도록 한다.

Test087.java
-배열의 배열(2차원 배열)
int arr [][] = new int [3][4];
[] [] [] [] ~ 웅웅 ↓↓↓↓ 숑숑이! 
[] [] [] [] ~
[] [] [] [] ~

Test088.java
-배열의 배열(2차원 배열)

// 배열의 배열(다차원 배열)을 활용하여
// 다음과 같은 데이터를 요소로 취하는 배열 (5 x 5)을 구성하고
// 그 결과를 출력하는 프로그램을 구현한다.

// 실행 예)
/*
 1  2  3  4  5
 6  7  8  9 10
11 12 13 14 15
16 18 18 19 20
21 22 23 24 25
int arr [][] = new int [5][5];
1부터 25까지 넣고 배열 전체 요소 출력 ㄱㄱ

Test089.java
-배열의 배열(2차원 배열)

// 실행 예)
/*
   1   2   3   4   5  
   2   3   4   5   6  
   3   4   5   6   7  
   4   5   6   7   8  
   5   6   7   8   9  

계속하려면 아무 키나 누르십시오 . . .
[5][6]만들고 두번째 웅웅이 보니까 1씩 커짐.

Test090.java♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥
-배열의 배열(2차원 배열)

// 배열의 배열(다차원 배열)을 활용하여
// 다음과 같은 데이터를 요소로 취하는 배열을 구성하고
// 그 결과를 출력하는 프로그램을 구현한다.

// 실행 예)
/*
   1   2   3   4   5   
   5   1   2   3   4   
   4   5   1   2   3   
   3   4   5   1   2  
   2   3   4   5   1   
출력 시작점을 확인!! 이거 존나 어려웠삼.

Test091.java♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥
-배열의 배열(2차원 배열)

// 배열의 배열(다차원 배열)을 활용하여
// 다음과 같은 데이터를 요소로 취하는 배열을 구성하고
// 그 결과를 출력하는 프로그램을 구현한다.

// 실행 예)
/*
   1   8   9    16   17   
   2   7   10   15   18   
   3   6   11   14   19   
   4   5   12   13   20     

계속하려면 아무 키나 누르십시오 . . .
시작점 확인!! 배열문제는 시작점을 확인해라!

Test092.java♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥
-배열의 배열(2차원 배열)

// 배열의 배열(다차원 배열)을 활용하여
// 다음과 같은 데이터를 요소로 취하는 배열을 구성하고
// 그 결과를 출력하는 프로그램을 구현한다.

// 실행 예)
/*
   E   J   O   T   Y
   D   I   N   S   X   
   C   H   M   R   W   
   B   G   L   Q   V   
   A   F   K   P   U     

계속하려면 아무 키나 누르십시오 . . .
역순!!!!!!!!!!!!!!!! 배열은 문제 종종 풀어보자잉

Test093.java♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥
-배열의 배열(2차원 배열)

// 배열의 배열(다차원 배열)을 활용하여
// 다음과 같은 데이터를 요소로 취하는 배열을 구성하고
// 그 결과를 출력하는 프로그램을 구현한다.

// 실행 예)
/*
   1   2   3   4   10
   5   6   7   8   26
   9  10  11  12   42
  13  14  15  16   58
  28  32  36  40  136

Test094.java	과제
- 배열의 배열(2차원 배열)

//   배열의 배열(다차원 배열)을 활용하여
//   다음과 같은 데이터를 요소로 취하는 배열을 구성하고
//   그 결과를 출력하는 프로그램을 구현한다.

// 실행 예)
/*
A  B  C  D  E
F  G  H  I  J
K  L  M  N  O
P  Q  R  S  T
U  V  W  X  Y

계속하려면 아무 키나 누르십시오 . . .

Test095.java	과제
-배열의 배열(2차원 배열)


//○ 과제
//   배열의 배열(다차원 배열)을 활용하여
//   다음과 같은 데이터를 요소로 취하는 배열을 구성하고
//   그 결과를 출력하는 프로그램을 구현한다.

// 실행 예)
/*
A
B  C
D  E  F
G  H  I  J
K  L  M  N  O

계속하려면 아무 키나 누르십시오 . . .

Test096.java	과제
-배열의 배열(2차원 배열)
//   배열의 배열(다차원 배열)을 활용하여
//   다음과 같은 데이터를 요소로 취하는 배열을 구성하고
//   그 결과를 출력하는 프로그램을 구현한다.

// 실행 예)
/*
A
C  B 
D  E  F
J  I  H  G 
K  L  M  N  O

계속하려면 아무 키나 누르십시오 . . .

Test097.java
-배열과 난수 처리(※ Random 클래스 활용)
//배열과 난수 처리(※ Random 클래스 활용)

//사용자로부터 임의의 정수를 입력받아
//그 정수의 갯수만큼 난수를 발생시켜 배열에 담고
//배열에 담겨있는 데이터들 중
//가장 큰 값과 가장 작은 값을 선택하여
//결과를 출력하는 프로그램을 구현한다.

//실행 예)
//발생시킬 난수의 갯수 입력 : 10
//50 7 24 81 72 45 61 38 1 99 
//가장 큰 값 : 99, 가장 작은 값 : 1
//계속하려면 .........

무작위 정수(난수) 발생하기 위해서는
난수 발생 전용 객체가 필요하다.
『java.util.Random』
랜덤 인스턴스 생성. // BufferedReader나 Scanner처럼이용.
Random rd = new Random();
Random 클래스의 『nextInt()』 메소드
0 ~ 매개변수로 넘겨받은 정수 n - 1까지의 수 중
무작위 정수(난수) 1개를 발생시킨다.
rd.nextInt(10) // 0 ~ 9
개수는 한개, 그 수의 범위가 0 ~ 9임.
다시 기억해라 개수는 1개이고 범위가 0~9인것.!
가장 큰값, 가장 작은 값은 배열 엉망되도 좋으니 자리바꾸기말고
초기화를이용해라!!!!!!!!!!!!

Test098.java
// 배열의 복사

// Test099.java 파일과 비교 ~!!!

// ※ 배열 변수의 복사에는 데이터 복사, 주소값 복사 두 가지 형태가 존재한다.

//    주소값 복사 → 얕은 복사 → 원본을 수정하면 복사본에 영향을 미치게 되는 복사 방법.
//                                (배열 뿐 아니라 모든 『참조형 데이터』에 해당하는 복사 방법.)

//    데이터 복사 → 깊은 복사 → 실제 요소로 들어있는 값에 대한 복사로
//                                원본을 수정해도 복사본에 영향으 미치지 않는 복사 방법.

// 주소값 복사
변수는 값타입입니다. 그래서 원본 바껴도 안바뀌고
배열은 배열전체를 복사하면 주소값복사(얕은 복사)가 되어
원본배열이 바뀌면 복사배열도 바뀝니다!!!!!!!!!!!!!!!

Test099.java
// 배열의 복사

//Test098.java 파일과 비교 ~!!!

// ※ 배열 변수의 복사에는 데이터 복사, 주소값 복사 두 가지 형태가 존재한다.

//    주소값 복사 → 얕은 복사 → 원본을 수정하면 복사본에 영향을 미치게 되는 복사 방법.
//                                (배열 뿐 아니라 모든 『참조형 데이터』에 해당하는 복사 방법.)

//    데이터 복사 → 깊은 복사 → 실제 요소로 들어있는 값에 대한 복사로
//                                원본을 수정해도 복사본에 영향으 미치지 않는 복사 방법.

// 데이터 복사
// - int 형 배열에 대한 깊은 의미의 복사를 처리하는
//   메소드를 정의하는 형태로 실습
프리미티브 자료형 복사처럼(값타입) 요소 하나하나를 복사해서 원본이 바뀌어도 
복사배열은 바뀌지 않음!
1. 배열은 객체이다.
2. 배열.length 사용이 가능하다. length는 객체가 가진 변수
3. 배열.clone(); 는 객체와 설계도 
4. 객체를 반환하는 자바가 제공한 메소드

원본배열의 요소를 하나하나 복사한다는 점이 주소값 복사랑 다른점!
요소 하나하나 값타입을 복사! 배열은 참조타입!

Test100.java
-정보 은닉과 접근 제어 지시자(접근지정자, 접근제한자...)
	// 정보 은닉(Information Hiing)
	// 멤버 변수,인스터스 변수 ,전역 변수
	// 『private』이라는 접근제어지시자의 선언은
	// 클래스 내부에서만 접근 및 참조가 가능하게 하겠다는 의미.
	// ↓ 
	// CircleTest2 의 멤버 변수 선언, 인스턴스 변수, 전역변수
	//int num;	//→ 인스턴스 생성 시, 메모리 할당 받음.
접근제어 지시자
=접근 지정자
=접근 제한자
=접근 제어자

public    : 모든 접근 허용

protected   : 

(default)   : 접근제어 지시자 안쓰면 디폴트

private   : 나혼자만 접근 허용 == 클래스 내부에서만 접근 및 참조가 가능하게 하겠다는 의미.

              ■■■접근제어 지시자의 관계■■■

지시자	 클래스 내부    동일패키지    상속받은 클래스    이외의 영역

private      O              X               X                X

default      O              O               X                X

protected    O              O               O                X

public       O              O               O                O

            <접근제어의 허용범위>
※ public > protected > defalt > private
   넓다                           좁다

①   접근제어 지시자를 아무것도 붙히지 않으면 default이다.

②   default vs protected 
     『상속받은 클래스』
     protected만 가능.

ex) public class Test000
    ______
    접근제어지시자

{
	public static void main(String[] args)
	{
		(default) int a;
		_________
		접근제어지시자
	}
}

Test101.java
-클래스 설계
-배열 활용
-접근제어지시자와 정보은닉


// 사용자로부터 년, 월, 일을 입력받아
// 해당 날짜의 요일을 출력하는 프로그램을 구현한다.
// 단, 달력 클래스(Calendar)는 사용하지 않는다.
// 또한, 클래스의 개념을 활용하여 작성할 수 있도록 한다. (→WeekDay 클래스 설계)
// 그리고, 배열의 개념도 적용시켜서 작성할 수 있도록 한다.
// 접근제어지시자의 개념도 확인하여 작성할 수 있도록 한다.
// 최종적으로 WeekDay 클래스 설계를 통해
// Test101 클래스의 main() 메소드가 정상적으로 프로그램 실행 될 수 있도록 한다.

// ※ 1년 1월 1일 → "월요일"

// 실행 예)
// 년 월 일 입력 (공백 구분) : 2022 1 19
// 2022년 1월 19일 → 수요일
// 계속하려면 아무 키나....

// 2000년 5월 4일 → 목요일
// 계속하려면 아무 키나....

Test102.java
-static 변수(클래스변수)와 static 메소드(클래스메소드)

// ※ 실습 편의상 접근제어 지시자 생략
	// ※ 클래스 변수 또는 클래스 메소드는
	//    클래스 정보가 로딩되는 순간 메모리 할당이 이루어지며
	//    클래스 이름 또는 객체(인스턴스)를 통해 접근할 수 있다.
	//           → 둘 다 가능하다는 소리. 
	//              클래스의 이름으로 접근하는 것이 일반적!

	//    즉, 『new』 연산자를 통해 메모리를 할당 받지 않아도
	//    사용이 가능하다는 것이다.
static변수(클래스변수, class변수, 정적변수)
초기화블럭 여기에도 static가능 나중에배움.
초기화 → 생성자() (우선순위 Test080.java)

// ※ 인스턴스 변수 또는 인스턴스 메소드는
	//    동일한 클래스의 메소드에서는 바로 접근하는 것이 가능하지만
	//         → 둘다 인스턴스 메소드라면 객체생성안해도 가능

	//    클래스 메소드에서는 접근할 수 없다.
		→ 탄생시점이 다르다. 인스턴스 변수는 객체 생성시에 
                   만들어짐.

non - static변수(인스턴스변수, instance변수,동적변수)
non - static메소드(인스턴스메소드, instance메소드 , 동적메소드)
인스턴스가 클래스를 부른다 가능! → 동생이 형을 부른다 가능
클래스메소드가 인스턴스 변수를 부른다 불가능!!! → 동생안태어남.
static끼리도 탄생시점이 같아서 부를 수 있다.

// 클래스 변수에 접근하기 위해서는
『클래스명.변수명』의 형태로 클래스의 이름을 통해
접근하는 것이 가능하다.
-->> main() → 클래스 변수 a : 10
Test102에 대한 인스턴스 생성안해도 가능.
클래스 변수라!

클래스명을 직접쓴다!!! static!!!! 그래서 this를 썼던거임~!
// 같은 클래스 내부의 메소드이기 때문에
-->> main() → 클래스 변수 a : 10
같은 클래스 내에서 부르면 클래스명 생략가능!
같은 클래스 내부에 존재하기 때문에
클래스 이름을 생략하는 것이 가능하다.

★ 같은 클래스 내부에서
   클래스 메소드 호출 ( static 메소드 호출)
   클래스명 생략 가능!
클래스 메소드에서 클래스 메소드의 호출은 가능하며,(main()에서 print())
『클래스명.메소드명()』의 형태로 접근하여 호출하는 것이 가능하다.
또한, 지금은 같은 클래스 내부에 존재하기 때문에
클래스의 이름을 생략하는 것이 가능하다.

인스턴스 변수는 생성된 인스턴스를 통해서만 접근이 가능하다.
static main()이 탄생한 순간, 인스턴스 변수는 탄생안한다.
클래스가 로딩되는 순간임!!!!!!!!!!!!!
→ 인스턴스변수든 메소드든 객체가 생성되어야 탄생한다
   main에서 인스턴스 변수, 메소드 호출 불가능
   형이 동생 부르기 불가능 동생 태어난지 몰라

 ※ 클래스 변수나 클래스 메소드는
    『생성된인스턴스명.변수명』 『생성된인스턴스명.메소드명()』 가능
    『클래스명.변수명』  『클래스명.메소드명()』 일반적임 가능

인스턴스 변수는 객체마다 다름.
클래스 변수는 한번 초기화 하면 다 같음!

클래스하면 "공유"와 "탄생시점"
스테이플러(공유) 딱풀(객체전용변수)

Test103.java
-클래스와 인스턴스 활용

// 학생별로 국어점수, 영어점수, 수학점수를 입력받아
// 총점, 평균을 계산하는 프로그램을 구현한다.
// 단, 클래스의 개념을 활용하여 작성할 수 있도록 한다.
// 또한, 이 과정에서 배열을 적극적으로 활용할 수 있도록 한다.
// 클래스 설계는 다음의 가이드라인에 따라 진행할 수 있도록 한다.

// 프로그램을 구성하는 클래스
// 1. Record 클래스
//    - 속성만 존재하는 클래스로 설계할 것 ~!!
//
// 2. Sungjuk 클래스
//    - 인원 수를 입력받아, 입력받은 인원 수 만큼
//    이름, 국어점수 영어점수, 수학점수를 입력받고
//    총점과 평균을 산출하는 클래스로 설계할 것 ~!!
//    속성 : 인원수, Record 형태의 배열
//    기능 : 인원수 입력, 상세 데이터 입력, 총점 및 평균 연산, 결과 출력
//
// 3. Test103 클래스
//    - main() 메소드가 존재하는 외부 클래스로 설계할 것~!!

한 java파일안에서 public은 하나! 왜냐하면 그걸로 자바파일 만들어져.
 인스턴스 생성 전에 다른 클래스에서 활용할거라 
						// static이 붙음!

같은 클래스는 인스턴스 생성 전에 활용가능합니다~!
클래스명.변수명으로 활용하자!
Record r1 = new Record(); 하면 r1객체 만듬.
Record형식의 객체 생성.
Record class에 데이터 변수가 있으면
Record.rank 이런식으로 활용가능

Test104.java
/*=====================================
    ■■■ 클래스와 인스턴스 ■■■
======================================*/

// 클래스와 인스턴스 활용

// 1 ~ 3 사이의 난수를 발생시켜서
// 가위, 바위, 보 게임 프로그램을 구현한다.
// 단, 클래스의 개념을 활용하여 처리할 수 있도록 한다.
// 또한, 배열을 활용하여 처리할 수 있도록 한다.
// 최종적으로 RpsGame 클래스를 완성할 수 있도록 한다.

// ※ 기준 데이터 → 1: 가위, 2: 바위, 3: 보

//실행 예)
// 1: 가위, 2: 바위, 3: 보 중 입력(1 ~ 3) : 4
// 1: 가위, 2: 바위, 3: 보 중 입력(1 ~ 3) : -2
// 1: 가위, 2: 바위, 3: 보 중 입력(1 ~ 3) : 2

// -유저 : 바위
// -컴퓨터 :보

// >> 승부 최종 결과 : 컴퓨터가 이겼습니다 ~!!
// 계속하려면 아무 키나 누르세요...

난수 만들기
① 랜덤 인스턴스 생성.
② rd.nextInt(매개변수) → 0부터 매개변수-1까지 중 하나로 난수 발생
   난수 1개가 나오는거임.
가위바위보 조건을 잘 생각하자!

Test105.java
-메소드 중복정의(Method Overloading)

○ 메소드 오버로딩의 개요
   메소드 오버로딩(Overloading)이란
   메소드가 처리하는 기능은 같고
   메소드 괄호 속에 오는 인수(인자 == 매개변수 == 파라미터)의 갯수가 다르거나
   자료형(Data Type)이 다른 경우
   메소드의 이름을 동일한 이름으로 부여하여 메소드를 정의할 수 있도록
   문법적으로 허용하게 되는데
   이를 메소드 오버로딩(Method Overloading)이라고 한다.

- 메소드명이 같아도 매개변수가 다르면 누굴 부르는지 식별이 가능하다.
- 원래는 !! default로는 메소드의 이름은 같으면 안되는데
  오버로딩으로 같아도 되는 것이다.

Test106.java ★★★★★
-메소드 중복정의(Method Overloading)
- 메소드 오버로딩이 가능한 형태와 불가능한 형태.
※ 자바는 대입연산자 『=』가 있으면 오른쪽 부터 처리!
print(3.14);
double result = print(3.14);

두 개는 오른쪽만 봤을 때 같은 말. 

-/public static void print(double e) {return 10.0} 
//--정의 불가 void인데 return자료형 반환이라

-public static void print(char c) {}    
//-- 일단 됨. 근데 자동형변환 규칙 check~!!

 public static double print(double e) {return 10.0;}//--(x) check~!!

Test107.java ★★★
-만년달력

// 다음과 같은 기능의 프로그램을 구현한다.

// 실행 예)
// 『연도』를 입력하세요 : 2020
// 『월』를 입력하세요 : 6

/*
       [2020년 6월]

   일 월 화 수 목 금 토
   ====================
             1  2  3  4
   5  6  7  8  9  10 11
   12 13 14 15 16 17 18
   19 20 21 ....

   계속하려면 아무 키나 ...
*/
- 시작요일을 알고
- 그 요일부터 해당 월의 날짜마지막까지 출력하면 된다.
- 방법은 출력하고 개행하는 별찍기 방법과
  배열에 담아서 출력하는 방법 → 배열은 안에 숫자가 안들어가면
  0을 출력한다 주의!

Test108.java
-주민등록번호 유효성 검사
/*
○ 주민등록번호 검증 공식

   ① 마지막 자리를 제외한 앞자리 수를 규칙에 맞게 곱한다.

   123456-1234567 (주민번호)
   ****** ****** ---------------------- 각 자릿수에 곱하기
   234567 892345 (각 자리에 곱해질 수)

   ② 규칙에 맞게 곱셈 연산을 수행한 결과를 모두 더한다.

   ex) 7 5 0 6 1 5 - 1 8 6 2 1 3 3
       * * * * * *   * * * * * *
	   2 3 4 5 6 7   8 9 2 3 4 5
	   ----------------------------
	   → 14 + ... + 15
	    9 8 0 6 0 6 - 2 1 6 9 2 1 7
		2 3 4 5 6 7   8 9 2 3 4 5
		
		
	      
		  == 217
	③ 더해진 결과값을 11로 나누어 『나머지』를 취한다.
	         19  → 몫(x)
	      ----------
	   11 | 217
	        11 
		  ----------
		    107
			 99
		  ----------
		      8 → 나머지(O)
	
	④ 11에서 나머지 8을 뺀 결과값을 구한다.
	   
	   11 - 8 → 3

	   ※ ③의 처리 과정에서 나머지가 0인 경우 → 11-0 → 11
	                         나머지가 1인 경우 → 11-1 → 10

		  이를 다시 10으로 나누어 나머지를 취한다.     → 1
		                                               → 0
	      
	  
	⑤ ④의 연산 결과가 주민번호를 구성하는 마지막 숫자와 
	   일치하는지의 여부를 비교한다.

	   일치   → 유효한 주민번호
	   불일치 → 잘못된 주민번호
return; → 메소드 종료 → main()메소드 종료 → 프로그램 종료
continue; → 뒷부분은 무시하고 계속해라. → 해당 블래이스 뒤에가 뒷부분.
str.length() : 문자열의 길이. str이라는 인스턴스의 메소드를 호출한 거고. 
               인스턴스 생성없이도 가능하니 length()메소드는 static메소드구나.
               공백 포함해서 길이를 센다!!!!

str.substring(2,5); : 2부터 5-1까지 출력. 인덱스는 0부터.
                      뒤에가 인덱스의 범위를 초과하면 StringIndexOutOfBoundsExcep 에러발생
                      매개변수하나만 주면 해당 인덱스번호만 출력.

Scanner는 공백구분하면서 다음 문자를 자동으로 가져가지 않음.

Test109.java
-정렬(Sort) 알고리즘
-선택 정렬(Selection Sort)
/*
○ 정렬
   : 데이터를 특정한 규칙(기준)에 맞게 순서대로 나열 (오름차순, 내림차순)

○ 정렬의 목적
   : 데이터 처리 과정의 편의성이나 가독성을 높이기 위함
     → 보기 좋게 ... 검색하기 위함

○ 정렬의 종류
   : 선택 정렬, 버블 정렬, 삽입 정렬, 힙 정렬, 퀵 정렬, 쉘 정렬 ....
     → 회사에서 order by 못쓰게 할 정도로 리소스 소모가 크다.

     
*/

// 선택 정렬(Selection Sort)
// 하나를 기준으로 비교해간다~1

// 실행 예)
// Source Data : 52 42 12 62 60
// Sorted Data : 12 42 52 60 62
// 계속하려면 아무 키나 누르세요...

int [] a = {52, 42, 12, 62, 60};
		/*
		42 52 12 62 60			0 vs 1
		== -- 
		12 52 42 62 60			0 vs 2
		==    --
		12 52 42 62 60			0 vs 3
		==       --
		12 52 42 62 60			0 vs 4
		==	    --
		------------------------1회전
		12 42 52 62 60			1 vs 2
		   == --
		12 42 52 62 60			1 vs 3
		   ==    --
		12 42 52 62 60			1 vs 4
		   ==       --
		------------------------2회전
		12 42 52 62 60			2 vs 3
		      == -- 
		12 42 52 62 60			2 vs 4
		      ==    --
		------------------------3회전
		12 42 52 60 62			3 vs 4
		         == --
		------------------------4회전

		*/
-향상된 for문(foreach 구문)
		// 자료구조를 탈탈 털겠다! a에 첨부터 순차적으로 접근하겠다.
		// int배열타입 ㄴㄴ 하나의 요소의 데이터 타입 = int타입
		/*
		for (요소 하나의 자료타입 변수명(아무거나)	:①자료구조)
		{
			a자료구조에 제일 첫번째 가져와서 n에 담아서 반복문 수행
			a끝까지 a.length만큼
			5번 돌아요... a의 방갯수만큼!
			a에서 끄집어낼게 없으면 반복문끝나요..

for (int n :a )
			System.out.print(n + " "); //a[0], a[i], a[2], ..., a[4]
		System.out.println();

// Selection Sort
		for (i=0;i<a.length ;i++ ) // 웅웅 ~~비교기준데이터 0 1 2 3 //// 52,~,60까지만
		{
			for (j=i;j<a.length ;j++ ) //쑝쑝~!!!! 비교대상데이터  1234 234 34 4
			{
				if (a[i] < a[j])			//if (a[i] > a[j]) //오름차순 정렬
				{
					//자리바꾸기
					a[i] = a[i]^a[j];
					a[j] = a[j]^a[i];
					a[i] = a[i]^a[j];
				}

			}
		}

Test110.java
-정렬(Sort) 알고리즘
-버블 정렬(거품 정렬, Bubble Sort)
int [] a = {52, 42, 12, 62, 60};

		/*
		42 52 12 62 60      01
		== --
		42 12 52 62 60      12
		   == --
		42 12 52 62 60      23
		      == --
		42 12 52 60 62      34
			 == --
		------------------------1회전 선택정렬이랑 다른 점 : 선택 정렬 맨 왼쪽이 fix,						기준을 0~3까지
															 버블 정렬 맨 오른족이 fix
		12 42 52 60 62 //-- 다시 첨부터          01
		== --
		12 42 52 60 62                           12
		   == --
		12 42 52 60 62 //-- 60 vs 62는 1회전때 끝남.      23
		      == --
	    ------------------------2회전																		기준을 0~2까지
		12 42 52 60 62        01
		== --
		12 42 52 60 62        12
		   == --
		------------------------3회전																		기준을 0~1까지
		12 42 52 60 62 
		== --
		------------------------4회전																		기준을 0까지	
		*/

Test111.java
-정렬(Sort) 알고리즘
-향상된 버블 정렬(Bubble Sort)


// ※ 앞에서 본 Selection Sort(Test109) 이나 Bubble Sort(Test110)의 성능은 같다.
//    성능은 소스코드로 평가되지 않음.
//    반복의 횟수로 평가
//    (→ 반복의 횟수로 추정)
//    반복의 횟수가 같음. 1회전 ~ 4회전

//    하지만, 향상된 Bubble Sort는 대상 데이터의 구조에 따라서
//    일반 Bubble Sort 나 Selection Sort 보다 성능이 좋을 수 있다.

// 원본 데이터 : 61 15 20 22 30
//				 15 20 22 30 61	- 1회전(스왑 발생 → true → 다음 회전 진행 O)	
//				 15 20 22 30 61	- 2회전(스왑 발생 → false → 다음 회전 진행 X)
//               → 반복문 덜 하겠지? ㅇㅋ

//==> 1회전 수행 ... 2회전 수행 ... 을 해보았더니 ...
//    2회전에서 스왑(자리바꿈)이 전혀 일어나지 않았기 때문에
//    불필요한 추가 연산(더 이상의 회전)은 무의미한 것으로 판단하여
//    수행하지 않는다.


// 실행 예)
// Source Data : 10 50 20 30 40
// Sorted Date : 10 20 30 40 50
int [] a = {10, 50, 20, 30, 40};
		/*
		10, 50, 20, 30, 40
		== --
		10, 20, 50, 30, 40
		    ==  --
		10, 20, 30, 50, 40
		        ==  --
		10, 20, 30, 40, 50
		            ==  --
	    ------------------------1회전 → 스왑 발생
		10, 20, 30, 40, 50
		==  --
		10, 20, 30, 40, 50
		    ==  --
		10, 20, 30, 40, 50
			==  --
		------------------------2회전 → 스왑 발생하지 않음.

				X

				X
		
		------------------------3회전 → X
		
				X

		------------------------4회전 → X
		*/

향상된 버블정렬 → do while문으로 시작한다.
이유는? 반드시 1회전은 하기 때문이다. break를 안해도된다.


Test112.java	과제
-정렬(Sort) 알고리즘

// ○ 과제
//    사용자로부터 여러 학생의 성적 데이터를 입력받아
//    점수가 높은 학생부터 낮은순으로 등수를 부여하여
//    결과를 출력하는 프로그램을 구현한다.
//    단, 배열과 정렬 알고리즘을 활용하여 작성할 수 있도록 한다.


// 실행 예)
// 인원 수 입력 : 5
// 이름 점수 입력(1, 공백 구분) : 이아린 90
// 이름 점수 입력(2, 공백 구분) : 박현수 80
// 이름 점수 입력(3, 공백 구분) : 이지연 85
// 이름 점수 입력(4, 공백 구분) : 서민지 75
// 이름 점수 입력(5, 공백 구분) : 김민성 95

/*
--------------
1등 김민성 95
2등 이아린 90
3등 이지연 85
4등 박현수 80
5등 서민지 75
--------------
계속하려면 아무 키나 누르세요...
*/

Test113.java
-클래스 고급
// 상속(Inheritance)

/*
○ 상속(Inheritance)이란
   새로 설계(생성)하고자 하는 클래스가
   이미 설계되어 있는 다른 클래스의 기능과 중복되는 경우
   이미 설계된 클래스의 일부분이나 전체 구조를 공유할 수 있도록 하는 기능을 의미한다.

   즉, 상속은 객체를 좀 더 쉽게 만들 수 있는
   고수준의 재사용성(reusability)을 확보하고
   객체간의 관계를 구성함으로써
   객체 지향의 또 다른 특징인 『다형성』의 문법적 토대가 된다.

   상속은 기존 프로그램의 클래스 내용을 공유함으로써
   중복된 코드들을 재작성할 필요 없이
   반복적이고 세부적인 작업을 처리하지 않기 대문에
   프로그램을 작성하는 시간을 절약할 수 있고
   유지보수를 편리하게 할 수 있으며,
   프로그램의 길이도 짧아지게 된다.

   또한, 이미 작성된 프로그램들은 앞서 테스트되었기 때문에
   오류를 줄일 수 있어 현재 작성 중인 프로그램에만 전념할 수 있다.

※ 주의할 점 ★★★★★
   자바는 『다.중.상.속』을 지원하지 않기 때문에
   두 개 이상의 클래스로부터 상속받을 수 없다.

   자바는 『단.일.상.속』만 지원한다.

자바에서 상속은 자식이 "우리 부모님 누구야 ~!!!!" 하는 거!
*/
// 상위 클래스 == 부모 클래스 == Super클래스 → 물려주는 클래스
// 하위 클래스 == 자식 클래스 == Sub 클래스  → 상속받는 클래스


// 접근제어지시자 default vs protected
//                           ---------
//                 상속x       상속o

-자식클래스명 extends 부모클래스
-extends하는 순간
 부모의 모든것이 상속된다. 하지만!!!!
 생성자는 상속대상에서 제외.
 접근제어지시자 default도 상속에서 제외.
 (같은 패키지면 접근 가능하다.)

※ 모든 자식 클래스의 생성자 안에는 부모 클래스의 생성자 호출이 포함된다.
   생성자 문법 : 생성자 내부에서 또다른 생성자를 호출하는 문법
                 가능하다. 단, 생성자 내부에서 가장 먼저 실행된다.

※ this(0); 클래스명으로 직접부르는것은 불가능하다
            → static 문법이다. 그래서 부모 클래스도 직접적으로 명시 불가능
                                                         → super키워드 사용.
            this는 이 키워드가 포함된 클래스 따라가기
            super은 포함된 클래스의 부모(상위)클래스로 치환

Test114.java
-클래스 고급
// 상속(Inheritance)

// ※ super

// static 으로 선언되지 않은 메소드에서 사용되며 → 클래스변수 ,메소드에서는 클래스명을 대놓고 쓸 수 있다. static이없어야 this랑 super가능.
// 현재 클래스가 상속받는 상위 클래스의 객체를 가리킨다.
// super 는 상위 클래스의 생성자를 호출하거나
// 상위 클래스의 멤버 변수 또는 메소드를 호출할 때 사용할 수 있다.

// 하위 클래스의 생성자에서 상위 클래스의 생성자를 호출할 때에는
// 하위 클래스의 생성자 정의 구문에서 맨 처음에만 위치할 수 있다. → 생성자 문법 : 내부에서 다른 생성자 호출 가능, 가장 먼저 호출. 메소드 내부에서 순차적가능

// ※ 생성자와 클래스 상속간의 관계

//    하위 클래스는 상위 클래스의 멤버를 상속받지만,
//    생성자는 상속 대상에서 제외된다.
//    그리고 하위 클래스의 생성자가 호출될 때
//    자동으로 상위 클래스의 생성자를 호출하게 된다.
//    이 때, 상위 클래스의 생성자는
//    인수가 없는 생성자(default 생성자 형태)가 호출된다. → 자동으로 될 때만!

// 상위 클래스 및 하위 클래스 (즉, 상속 관계에 있는 클래스)를 설계하는 과정에서
// 상위 클래스의 생성자를 정의하지(작성하지) 않거나 → 디폴트 생성자
// 인수가 없는 생성자만을 정의한(작성한) 경우 → 디폴트 생성자
// 명시적으로 하위 클래스에서 상위 클래스의 생성자를 호출하지 않아도
// 아무런 문제가 발생하지 않지만
// 상위 클래스에 인자가 있는 생성자만 존재하는 경우에는
// 주의해야 한다.

// 예를 들어 .... 다음에서 ...
/*
	class A_class
	{
		A_class(int n)
		{
		}
	}

	class B_class extends A_class
	{
		B_class()
		{
			super();
		}
	}
*/
// 하위 클래스인 B_class 의 생성자에서
// 명시적으로 A_class의 생성자를 호출하지 않으면
// 자동으로 인자가 없는 생성자를 호출한다.
// 하지만, A_class 에는 인자가 있는 생성자만 존재하고
// 인자가 없는 생성자는 존재하지 않기 때문에 에러 발생한다.
// 따라서, B_class 생성자의 선두에
// 다음처럼 명시적으로 상위 클래스의 생성자 호출 구문을
// 작성해야 한다.
/*
	class A_class
	{
		A_class(int n)
		{
		}
	}

	class B_class extends A_class
	{
		B_class()
		{
			super(10);
			...
			...
		}
	}
*/

※ 상속 시 주의할 사항
   
   상위 클래스에서 선언된 멤버 변수의 이름과
   하위 클래스에서 선언된 멤버 변수의 이름이 같으면
   상위 클래스의 멤버 변수는 무시된다.
   이 때, 상위 클래스의 멤버 변수를 사용하기 위해서는
   『super』 키워드를 이용한다.

   동일한 이름의 멤버 변수나 동일한 이름의 메소드가
   한 클래스 안에 선언되거나 정의되는 경우 기본적으로 에러 발생한다.
   단, 메소드의 경우에는 매개변수의 갯수나 타입이 다른 경우
   에러가 발생하지 않고 이들을 서로 다른 메소드로 취급하게 된다.
	→ 메소드 오버로딩.
*/

// 삼국지전편							super.삼국지전편    
// (내가 원래 갖고 있던 것)				(부모님으로부터 물려받은 것)


상속 대상에서 제외
-생성자(나중에 자식 생성자에서 디폴트생성자 자동호출 , 이거 싫으면 명시적으로 해줘)
-defalt, private 은 불가.
-clac(매개변수) 여기서 매개변수는 지역변수임.
@Override //-- 어노테이션(annotation) - metadata - JDK 1.5
	          //   컴파일해도 사라지지 않는 주석

// ※ 메소드 오버라이딩(Method Overriding)
	//    
	//    상위 클래스를 상속받은 하위 클래스에서
	//    상위 클래스에 정의된 메소드를 다시 정의하는 것으로(재정의)
	//    객체 지향 프로그래밍의 특징인 다형성을 나타낸다.
	//    재정의(Overriding)는 반드시 상속 관계에 있어야 하며,
	//    메소드 이름, 리턴 타입, 매개변수의 갯수나 타입이
	//    완전히 일치해야 한다.

★★★오버라이딩 vs 오버로딩!!★★★
오버라이딩은 상속관계에서 메소드를 재정의하는 것
오버로딩은 메소드 이름이 원래는 달라야하는데 매개변수의 갯수나
자료타입이 다르면 메소드 이름 같은 걸 허용하는 것!!

/*
==========================================================================
상위 클래스		|	하위 클래스		 | 결과
--------------------------------------------------------------------------
생성자를	    |생성자 정의 안함    |→ 가능하다.
정의하지        |인수가 없는 생성자  |→ 가능하다.
않음		    |인수가 있는 생성자  |→ 가능하다.
--------------------------------------------------------------------------
인수가	        |생성자 정의 안함    |→ 가능하다.
없는			|인수가 없는 생성자  |→ 가능하다.
생성자만 정의   |인수가 있는 생성자  |→ 가능하다.
--------------------------------------------------------------------------
인수가			|생성자 정의 안함    |→ 에러 발생.
있는			|인수가 없는 생성자  |→ 상위 클래스의 해당 생성자를 호출하지 않으면 에러 발생. super(10)이면 가능.
생성자만 정의   |인수가 있는 생성자  |→ 상위 클래스의 해당 생성자를 호출하지 않으면 에러 발생. super(10)이면 가능.
==========================================================================
*/
// 상위 클래스에 인수가 있는 생성자 정의 : 사용자 정의 생성자가 있다면
// 하위 클래스는 무족권 사용자 정의 생성자임. 일단.

Test115.java
-클래스 고급
-상속(Inheritance)
// 다음과 같은 프로그램을 구현한다.
// 단, 상속의 개념을 적용하여 작성할 수 있도록 한다.

// 실행 예)
// 임의의 두 정수 입력(공백 구분):  20 15
// 연산자 입력(+ - * /): -
// >> 20 - 15 = 5.00
// 계속하려면.....

// ※ 문자열.split("구분자")	//-- 구분자 → 공백으로 써라
		//    문자열.split("\\s")	//-- 구분자 → 공백으로 써라
		//    ex)     "10 20 30 40 50".split("\\s");
		//    반환 → {"10","20","30","40","50"}
		//    요소를 문자열로 취하는 배열

		//    ex) "010-1234-1234".split("-");
		//    반환 → {"010","1234","1234"}
		//    요소를 문자열로 취하는 배열

Test116.java
-클래스 고급
-상속(Inheritance)
※ 메소드 오버라이딩(Method Overriding)의 특정
   - 메소드 이름, 리턴타입, 파라미터 수나 타입이 완전히 일치해야 한다.
   - 반드시 상속 관계가 있어야 한다.
   - 재정의된 하위 클래스의 메소드 접근제어지시자는
     상위 클래스의 메소드 접근제어지시자보다 범위가 크거나 같아야 한다.
	 예를 들어, 상위 클래스 메소드의 접근제어지시자가 『protected』인 경우
	 하위 클래스가 이 메소드를 오버라이딩(Overriding)하는 경우
	 접근제어지시자는 『protected』 또는 『public』이어야 한다.
   - 『static』,『final』,『private』 메소드는 오버라이딩(Overriding)할 수 없다.
	  --------
	  이미 클래스가 생성되면서 만들어지고 메모리 잡아서
	  바꾸기 힘듬. 탄생시점이 다름

	              -------
				  상속에 있어서 상수화도 여전~

				  		    ---------
							오버라이딩 전제 조건 상속이 가능해야함.
							private는 상속자체가 불가능! 나만 접근 가능!

   
   - Exception의 추가가 불가능하다.
     즉, 상위 메소드가 가지고 있는 기존 예외 사항에
	 새로운 Exception을 추가하는 것은 불가능 하다는 것이다.
	 자바에서 Exception도 객체입니다! 
	 예외처리를 추가추가추가하면 완전 다른애가 되버령
	 맘대로 Exception을 추가하면 가이드라인이 다 깨져버려!
	 */

System.out.println(((SuperTest116)ob).b);
		//--==>> 10
		// 변수 같은 경우 : 부모 변수, 자식 변수 메모리 위치가 다름
		//                   그래서 이게 가능
하지만!!

((SuperTest116)ob).write();

		// 100
		//	10
		//	Sub write() 메소드 : 100 : 20

	// check~!!
	// 메소드와 변수를 꼭 구분하여 정리할 것
	// 메소드는 오버라이딩하면 부모껄로 못돌아가
	// 근데 부모밑에 자식이 여럿이면 a가 오버라이딩한거
	// b는 그냥 부모꺼 받나? 영향 ㄴㄴ?????????

오버라이딩하면 예전으로 못돌아가~!!~!!

Test117.java
-클래스 고급
-추상 클래스 (Abstract)
○ 추상 클래스 (abstract)는
   
   선언만 있고 정의가 없는 하나 이상의 메소드(추상 메소드)를 갖는 클래스로
   하위 클래스에서 오버라이딩(Overriding)할 것으로 예상되는 메소드에 대해
   메모리 낭비 없이 미리 호출 계획을 세워두기 위해 만든다.

○ 형식 및 구조
   
   [접근제어지시자] abstract class 클래스명
   {
	   [접근제어지시자] abstract 자료형 메소드명([매개변수],...);
   }

○ 특징
   
   클래스가 적어도 하나 이상의 추상 메소드를 포함할 때
   그 클래스는 클래스 앞에 『abstract』 키워드를 붙여
   추상 클래스로 명시해야 하며
   추상 클래스로 선언한 경우에는
   불완전한 형태의 클래스이므로 객체를 생성할 수 없다.
   추상 메소드가 존재하지 않는 추상 클래스마저도
   객체를 생성할 수 없는 것이다.

   즉, 추상 클래스는 독립적으로 존재할 수 없기 때문에
   상속을 위해서만 존재하며
   추상 클래스에서 상속받은 하위 클래스에서는
   반드시 추상 메소드를 오버라이딩(Overriding) 해야 한다.
   → 오버라이딩 안하면 자식 클래스는 추상이고 클래스로써의 가치없음.

※ 『abstract』 키워드는
   클래스와 메소드에서만 사용할 수 있으며
   멤버 변수나 로컬 변수에서는 사용이 불가능하다.

   추상 클래스안에 클래스메소드나 인스턴스 메소드 정의는 가능하다.
   단, 인스턴스 생성은 안된다.

- protected는 접근제어지시자로서 상속받은 자식클래스에서 사용가능하기도
  하지만 사실은 같은 패키지라 가능한 것두 이따~!

- 추상 메소드(선언만 되어있음!!)

- //『final』 → 키워드로 인해
  // 이 클래스(SortInt117)를 상속받는 클래스에서
  // 이 메소드를 재정의(Method Overriding) 할 수 없다.

//SortInt117 ( 추상 클래스 ) 를 상속 받은 클래스 → 일단은 추상 클래스
// → 추상 메소드 (abstract)를 재정의 (Method Overriding) 하면 
//     클래스의 역할 가능하다.

→// 클래스(설계도)에서 오버라이딩해서 쓸만하게 해뒀으니
		// 클래스 역할 가능. 인스턴스 생성 가능

Test118.java
-상속 관계에 있는 클래스들 간의 캐스팅
- 업 캐스팅, 다운 캐스팅

상위 클래스 SuperTest118
하위 클래스 SubTest118

SUuperTest118 ob2; 
 → 놀라운 사실 이건 생성자가 없으니 가능합니다 에러 안떠요!!
 → SuperTest118타입으로 ob2이름의 변수를
    참조변수 형태로 쓸거라고 선언!!

cf) 참조변수
cf) 객체 생성자 (); 이때부터 메모리할당가능.

SubTest118 ob1 = new SubTest118();

SuperTest118 ob2 = ob1;
== 위아래같음! 자동형변환임. 작은걸(서브) 큰 그릇(슈퍼)에 담는다.
SuperTest118 ob2 = (SuperTest118)ob1;


확인 point
1. Overriding된 메소드는 덮어쓰기가 된거라
   다시 못돌아가!
   메소드랑 변수는 다름!!
   업캐스팅 되면 재정의한 이상 원래의 기능으로 못돌아가!!

2. 변수는 객체별로 따로 할당이 됩니다!
   그래서 클래스명.변수명 → 그 클래스의 변수가 출력
   메모리는 따로! 접근방식에 따라 변수에 따로 접근가능합니다
   → 값타입이니까

3. ob2.c 
   직접 클래스에 접근.
   c는 하위 클래스의 멤버 변수임으로 부모클래스에서는 안보여용

   대신 하위 클래스에서는 상위클래스 멤버변수가 보이지(상속받을 수 있는거면)

4.((SubTest118)ob2).print()
  → 부모에게 print()메소드 없어요
     다운캐스팅해서 하위 객체로 내려와서 print출력해요


상위 객체를 생성했을 때는
다운 캐스팅이 불가능하다.
슈퍼클래스를 통해서 자식클래스에 접근할 수 없다.   
하위 = 상위; //에러 발생.
하위 = (하위)상위; //다운 캐스팅. 런타임에러.


====가능====
1. 하위 객체 생성;	//-- check~!!!!!
2. 상위 = 하위;	// 업 캐스팅. 정상
3. 하위 = 상위; // 에러 발생. 자동형변환 문제 그래서 ↓
4. 하위 = (하위)상위; → 명시적	// 다운 캐스팅.정상
========================================================================
//※ 추가관찰 ----------------------------
		//    다운 캐스팅 가능 여부

		SuperTest118 ob3 = new SuperTest118();
		SubTest118 ob4;

		//System.out.println(((SubTest118)ob3).c);
		//이거도 불가능 왜냐하면 SuperTest118할때
		//SubTest118에 접근 불가
		//
		//System.out.println(ob3.c);
		//--== 부모한테 c가 안보여요 컴파일에러!
		//-- 상위 객체는 하위 객체의 멤버에 접근하는 것이 불가능하다.

		//ob4 = ob3;
		//--==>>에러 발생(컴파일 에러)
		// -- 상위 객체는 하위 객체에 담을 수 (참조할 수 ) 없다.
		//ob4 = (SubTest118)ob3;
		//ClassCastException: 런타임에러!
		//클래스를 캐스팅하는 과정에서 문제가 발생했습니다.
		// -- 작성된 구문의 문법적인 구조만 봤을 때
		//    다운 캐스팅이 이루어진 상황이다.
		//    하지만, 정상적인 캐스팅이 이루어지지 않는다.

		// 현재 SubTest118 객체에 대해 메모리 할당이 이루어지지 않은 상태이기 때문에
		// 인스턴스 생성, 메모리 할당을 하면 되는 것인가?ㄴㄴ
		// -- 그래도 안돼. 그렇게 따지면
		//    하위클래스에 대한 객체 생성을 하긴했는데
		//    메모리 할당이 아니라 슈퍼클래스를 통해 자식클래스에 접근할 수 
		//    있냐 없냐가 문제.
		// 다운 캐스팅은 불가능한 것이다.
========================================================================
○ 업 캐스팅, 다운 캐스팅 정상적으로 이루어지는 경우 ------------------------
   
	1. 하위 객체 생성;	//-- check~!!!!!
	2. 상위 = 하위;	// 업 캐스팅. 정상
	3. 하위 = 상위; // 에러 발생.
	4. 하위 = (하위)상위; → 명시적	// 다운 캐스팅.정상


○ 업 캐스팅, 다운 캐스팅 정상적으로 이루어지는 않는 경우 ------------------------
   
   1. 상위 객체 생성; //-- check~!!!!!
   2. 하위 = 상위; //에러 발생.
   3. 하위 = (하위)상위; //다운 캐스팅. 런타임에러.

※ 업 캐스팅은 항상 가능. 
   다운 캐스팅은 경우(1번)에 따라 가능.

class 학생 
{
}

class 호석
{
}

학생 ob = new 학생();
호석 ob1 = new 호석();

학생 ob = new 호석();
-------   -----------
상        하
가능.

Test119.java
-클래스 고급
-인터페이스(Interface)
○ 인터페이스(Interface)란
   
   완전히 미완성된 채로 남겨져
   인터페이스 안에 존재하는 그 어떤 메소드도
   몸체(정의부)가 없기 때문에 사실상 실행 부분이 존재하지 않는다.
   클래스를 위한 템플릿으로써의 기능을 수행하는
   추상 클래스의 한 종류이다.

   → 추상 클래스 인스턴스 생성 불가
      아직 미완성이기 때문에!

○ 인터페이스는 클래스와 달리 다중 상속이 가능하며
   인터페이스 자체도 상속된다.
   기존의 C++ 언어 등에서 지원되는 다중 상속이
   사용 과정에서 많은 문제점을 노출시켰기 때문에
   자바에서는 다중 상속의 개념을 인터페이스라는 개념으로 변형하여
   인터페이스를 통해 다중 상속을 구현하는 방법을 지원한다.


○ 인터페이스는 상수와 추상 메소드만 가질 수 있으며
   인터페이스 안의 메소드들은 접근제어지시자를 명시하지 않아도
   『public』으로 설정되어 클래스에서 구현(implements)함으로써
   바로 접근이 이루어질 수 있다.

○ 특징
   - 추상 클래스의 일종으로 선언만 있고 정의가 없다.
   - final 변수는 가질 수 있다.(상수의 개념)
   - 인터페이스는 『public static final』 상수만 만들 수 있다.
   - 인터페이스를 구현하기 위해서는 『extends』 대신에
     『implements』를 이용한다.
   - 하나 이상의 인터페이스를 implements할 수 있다.
   - 인터페이스의 모든 메소드를 Overriding 해야 한다.

   	 → 추상 메소드는 모두 Overriding 해야한다.

   - 인터페이스가 다른 인터페이스를 상속받을 수 있으며
     이 때, extends 키워드를 사용한다.
	 →implemants 인터페이스A extends 인터페이스B. 인터페이스C..
	 또 한, 클래스와 달리 인터페이스는 다중 상속이 가능하다.
   */
// 인터페이스의 멤버 변수는
	// 『static final』을 별도로 명시하지 않아도
	// 자동으로 『static final』인 상태~!!!

// 인터페이스의 메소드는 선언만 가능(정의 불가)
	// 자동으로 『abstract』인 상태
	// public abstract void print();
//클래스
//class DemoImpl
//class DemoImpl extends Demo //--(X)
//class DemoImpl implements Demo
//                  ↓
// implements하는 순간. 추상 클래스가 됨.

-Override하는 순간 자식 클래스앞에 abstract뗼 수 있음.
-인터페이스는 인스턴스 생성 불가
//Demo ob = (Demo)obTemp;
//Demo ob = obTemp; 같은겨

// ○ 업 캐스팅
// 인터페이스 객체는 상위 객체
Demo ob = new DemoImpl();
//-----   --------------
// 상             하

Test120.java
- 클래스 고급
- 인터페이스(Interface)
※ 인터페이스는 2개 이상을 구현(implements)할 수 있다.
   → 다중 상속이 되지 않는 부분을 보완(보충)하는 개념.

// JDK 1.5(5.0)에서는 인터페이스 메소드를
// 오버라이팅(OVerriding) 할 때
// 『@Overriding』 어노테이션(annotation)을 사용할 수 없다.
// 단, 상속받은 클래스의 메소드를 오버라이딩(Overriding)할 때에는
// JDK 1.5에서도 『@Overriding』 어노테이션(annotation) 사용이 가능하다.

((BDemo)ob2).print();
		((ADemo)ob3).write();
		//--==>>BDemo 인터페이스 메소드 print()...
		//		ADemo 인터페이스 메소드 write()...

		((DemoImpl)ob3).write();
		//--==>>ADemo 인터페이스 메소드 write()...
		//위에서 ADemo타입으로 바꼈습니다!
		//다운캐스팅
		//-- DemoImpl 클래스가 두 인터페이스를 모두
		//   구현했기 때문에 가능하다.

		// 만약 DemoImpl 클래스가 이들 중 한 인터페이스만 구현했다면
		// 이 구문은 런타임 에러 발생하는 구문이 된다.

Test121.java
- 클래스 고급
- 인터페이스(Interface)
// 인터페이스를 구현하는 추상 클래스 → 인터페이스에 추상메소드 2개중 하나만 구현.
abstract class DemoImpl implements Demo

// 추상 클래스를 상속받는 추상 클래스
//abstract class DemoImplSub extends DemoImpl
//				↓
//추상 클래스를 상속받는 클래스 → 남은 추상 메소드 1개도 구현해서 앞에 추상뗌.
class DemoImplSub extends DemoImpl

Test122.java
- 클래스 고급
- 인터페이스 (Interface)

Test123.java

Test124.java
-중첩 클래스
-실무에서 적극적으로 쓰이진않아요
○ 중첩 클래스
   
   중첩 클래스란 클래스 안에 다른 클래스가 설계되어 있는 형태로
   클래스 내부에서만 사용할 보조 클래스가 필요한 경우
   클래스를 중첩하여 프로그램의 구조를 보다 더 간단하고 알아보기 쉽도록
   만들 수 있는데 이러한 클래스를 중첩 클래스라 한다.
   이는 특정 클래스를 자신의 클래스 내부적인 용도로만
   사용할 목적으로 쓰이는데
   특정 클래스를 마치 자신의 멤버 변수나 메소드처럼 사용할 수 있게 한다.

○ 중첩 클래스의 종류(4가지)
   
   1. static 중첩 클래스(중첩 내부 클래스)
      클래스 내부에... 『public static class 클래스명』

	  중첩 클래스를 감싸는 외부 클래스 {} 안에 
	  static 을 붙인 새로운 클래스를 설계하는 것으로
	  모든 접근제어지시자를 사용할 수 있다.
	  static 중첩 클래스가 포함하고 있는 메소드에서는
	  외부 클래스의 인스턴스 변수나 인스턴스 메소드에는 접근할 수 없고,
	  (외부 클래스의 객체를 생성하지 않은 상태)
	  클래스 변수와 클래스 메소드만 접근할 수 있다.

	  - 프로그램의 구조를 보다 더 간단하고 알아보기 쉽게 구성할 수 있다.
	  - static으로 선언된 내부 클래스 이다.
	  - 중첩 클래스의 객체는 중첩 클래스를 포함하고 있는
	    외부 클래스의 객체와 동등하다.
	  - 외부 클래스의 클래스 변수와 클래스 메소드는
	    바로 접근하여 사용하는 것이 가능하다.
	  - 중첩 클래스와 중첩 클래스를 포함하고 있는 외부 클래스의
	    인스턴스 변수와 인스턴스 메소드는
		객체를 생성하여 서로 접근하는 것이 가능하다.
      - 중첩 클래스를 외부에서 단독으로 사용하는 것이 가능하다.

   2. 내부 클래스(inner class)
      클래스 내부에... 『public class 클래스명』

	  - static 중첩 클래스와 마찬가지로 프로그램 구조를 보다 더 간단하고
	    알아보기 쉽도록 한다.
	  - 외부 클래스의 메소드에서 내부 멤버 클래스를 사용하기 위해서는
	    반드시 내부 멤버 클래스 객체를 생성해 주어야 한다.
	  - 외부 클래스의 멤버 변수와 메소드를
	    객체 생성 없이 바로 사용하는 것이 가능하다.
	  - 내부 멤버 클래스는 외부에서 단독으로 객체를 생성하여
	    사용할 수 없다.
	    즉, 내부 멤버 클래스는 외부 클래스의 인스턴스 생성이
		선행되어야 한다는 것이다.
	  - static 으로 선언된 변수 또는 메소드를 가질 수 없다.

   3. 지역 클래스(로컬 클래스 ,local class)
      메소드 내부에...『public class 클래스명』
	                or 『public static class 클래스명』

	  - 클래스의 메소드 안에서 클래스를 정의하는 것으로
	    내부 멤버 클래스와 유사한 성격을 가지고 있긴 하지만
		접근제어지시자는 붙일 수 없다.

   4. 무명 클래스(익명 클래스, annoymous class)★ 얜 쓰임.
      이름 없는 클래스

	  - 클래스 또는 인터페이스에 대한 객체를 생성하면서
	    바로 클래스 또는 인터페이스를 정의하는 클래스.
	  - 정의하는 부분과 생성하는 부분이 하나로 묶여져
	    new 수식이 있는 곳에서 바로 클래스
		또는 인터페이스를 정의하는 것을 의미한다.

		new
		{
			...
		};

→ 중첩된 클래스는 바깥 클래스만!!!!!!!!쓴다.
   객체는 여기저기 다 쓰일라하는건데 얜 요상해.
   
   모바일의 이벤트.. 각각 독립적인 객체로 설정하면
   넘 많아서 리소스 소모가 너무 커요.

무명 클래스(익명 클래스, annoymous class)
      이름 없는 클래스
	  (이름을 붙힌다 → 호출하고 제어하고 ..
	    모바일 이벤트 처리에서 종종 사용!)

Test125.java
Test126.java
Test127.java
Test128.java
Test129.java
Test130.java

Test131.java

Test132.java
Test133.java
Test134.java
Test135.java
Test136.java
Test137.java
Test138.java
Test139.java
Test140.java
Test141.java









	