자바 기본 프로그래밍
Test001.java
-클래스 첫 이름은 대문자로 시작.
-mian()함수는 자바 인터프리터가 처음 찾는 함수
-메소드() : 호출하다.
-자바에서 함수(메소드)는 독립적으로 존재할 수 없다.
-→ 클래스에 정의되는 형태로 함수를 만든다.
-그래서 다른 학문(수학 등)에서 말하는 함수와 차이가 있다.
-→ 그래서 자바에서의 함수는 메소드라고 부른다.
-함수,메소드 → 기능,동작,행위
-메소드는 정의되어야 호출(println())으로 호출할 수 있다.

Test002.java
-컴파일 실행 실습

자바의 개요 및 특징
Test003.java
-println()메소드는 마지막에 라인 스킵(개행)을 한다.
-print()는 하지않는다.

자바 기본 프로그래밍
Test004.java
-변수와 자료형
-자료형 변수명; //-- 변수 선언
-변수명 = 값; //-- 초기화
-자료형 변수명 = 값 //-- 변수 선언 및 초기화 한번에
-자바에서는 '='대입연산자가 나오면 오른쪽 부터 처리를 해라!
-컴파일 에러 : javac.exe가 찾는다.
-런타임 에러 : 개발자의 의도와 다른 형태로 사용자가 사용할 때 나는 에러.
-알파테스트(개발자), 베타테스트(개발자가 아닌사람들의 테스트)
-클로즈테스트(특정 사용자가 대상), 오픈테스트(아무나),
-덧셈 연산자(+)는 피연산자 중 어느 하나라도 문자열 형태이면 ""
 산술연산자로써의 기능을 하지 않는다. 문자열 결합 연산자로 기능한다
 →처리 결과는 문자열 형태로 반환한다.
 뺄셈 연산자는 그런 기능이 없다!

Test005.java
-변수와 자료형
-변수 선언 → 메모리 공간 확보 / 할당
 자바야 자바야 나 int형 4byte로 변수 선언할거니까 자리예약좀 !!
- 연산 및 처리 → 확보한 메모리 공간에 데이터 담아내기
- '=' 대입 연산도 연산이다! 대입 연산자!!
-자동형변환, 명시적형변환

Test006.java
-변수와 자료형
-키워드 및 식별자
-스코프 영역 안에서 변수명은 식별자이다!!
 식별자 : 구분하기 위한
-문법적으로 변수명을 한글로는 가능하지만 실무에서 사용하지는 않는다!

Test007.java
-print() / println() / printf() / format()
-printf(), format()은 JDK 1.5부터 지원되는 메소드
-두 개 사용법은 같다.
-format()은 String에서 자주 쓴다.
-System.out.printf("○ + ○ + ○", 10, 20, 30);
-System.out.format("○ + ○ + ○", 10, 20, 30);
-서식 출력용 메소드
-출력하기 위해 틀짜놓고 하는것.
-메소드 뒤에 ln이 없기에 print()메소드 처럼 개행이 안된다.
-그래서 \n 혹은 %n으로 개행출력.
-%d == 10진수 정수형 ( 1, 10, 94 .. )
-%f == 실수(3.14 ...)
-%.2f : 소수점 이하 두 번째 자리까지 표현
        반올림함.
-%d로 틀짜고 실수를 넣으면 런타임에러가 발생한다 (컴파일에러는 문법을 봄)
-문법은 맞는데 개발자가 정수를 목적으로 코드 짰는데
 사용자가 실수를 넣어서 런타임 에러 발생.

Test008.java
-형 변환
-접미사활용
 1바이트 2바이트 4바이트  8바이트   4바이트(실수)  8바이트(실수)
-byte   < short   < int    < long   < float       < double
          char  
         2바이트
-boolean
  1바이트

//자료형의 종류와 구분
자료형		데이터		메모리 크기		표현 가능 범위
boolean		참과 거짓	1바이트			T,F

char		문자		2바이트			모든 유니코드 문자

byte		정수		1바이트			-128~ 127
short		정수		2바이트			-32768~ 32767
int		정수		4바이트			+- 21억
long		정수		8바이트			매우 큰 정수


float		실수		4바이트			매우 큰 실수
double		실수		8바이트			더 큰 실수




//자료형 변환

byte → short  ↘ 
		  int →long →float →double
        char   ↗

-자동형변환 : 큰거에 작은거는 자동으로 담긴다 (short가 long에 담긴다)
-명시적형변환(강제형변환), 자동형변환 위배가 아니더라도 
 어디서 형변환 된지 알려줄라고 쓸 때도 있삼!
int a;
char c;
a = c; → int형(4바이트 정수)에 char(2바이트 문자형) → 담긴다 → 자동형변환
c = a; → char(2바이트 문자형)에 int(4바이트 정수형) → 담기지 않음 → 자동형변환 위배
          작은그릇에 큰거 담을 수 없음
          c = (char)a; 
          a의 크기가 2바이트에 담길 크기면 명시적형변환으로 가능
long d = 10000000000;	//백억임
'=' 대입 연산자를 기준으로 우측의 상수 표현이
    int형 메모리에 해당 상수를 할당할 수 없다. 그래서 long으로 자료형 선언
    21억을 넘는다. 그래서 접미사 L을 뒤에 붙혀야 한다...

long d = 10000000000L; O
long d = 10000000000; X
int d = 10000000000; X
int d = 10000000000L; X

int e = 030;
System.out.println("e의 결과:" + e);
		//-->e의 결과:24
접두어 0 → 8진수로 바꿔줌.
030 →64, 8, 1 
8 x 3 = 24이기 때문에 24가됨.

Test009.java
-변수와 자료형 실습 및 테스트 : boolenan

Test010.java
-변수와 자료형 실습 및 테스트 : char
- '' 는 문자형 "" 은 문자열형
- char ch2 = '\n' → \n도 하나의 문자입니다~!

Test011.java
//나눗셈 연산 실습
- 정수와 정수의 나눈셈 ( 몫 반환 ) 
- 피 연산자로 실수가 포함되어 있는 나눗셈
  실수 기반의 연산 수행.
Like 덧셈 연산자는 피연산자가 문자열or 문자가 있으면 문자열 결합 연산자로 수행.



Test012.java
-원의 넓이와 둘레를 구하는 프로그램 구현
- final → 변수의 상수화하는 키워드
- 변수는 수시로 변할 수 있다.
  상수는 변하지 않는다 이름 없는 특징
- final 변수는 대문자로 쓰는 암묵적 룰!
- 언더바스코어 표기법 

Test013.java
-직사각형의 넓이와 둘레를 구하는 프로그램 구현

Test014.java
-자바의 기본 입출력 : BufferedReader 클래스
-버퍼 : 임시기억공간, Like 키보드같은 장치
-throws IOException : 오류나면 그 오류 메소드 밖으로 던질게 자바

BufferedReader br = new BufferedReader(new InputStreamReaer(System.in)); 
                                                           -----------
                                                           바이트 입력값
                                       ---------------------------------
                                       바이트 → 문자 번역기
---------------------------------------
        문자 입력을 읽어들이는 장치
br.readLine(); → BufferedReader의 readLine() → 문자열 반환!
Integer.parseInt() → 매개변수로 넘겨받은 문자열 데이터 → 정수형으로 변환
단, 이 때 넘겨받은 문자열 데이터는 숫자모양이여야 한다. (NuberFormat)

      
Test015.java
-삼각형의 밑변의 길이와 높이를 사용자로부터 입력받아
 삼각형의 넓이를 구하는 프로그램 구현

area = (double)length * height /2; //하나만 실수로 바꿔.
	//area = (double)length * height /2.0; //이게 깐지
-실수 기반의 연산을 수행해야해서 
 나눗셈 연산 : 피연산자 중 하나라도 실수면 실수기반 연산 수행!

Test016.java
-사용자로부터 이름, 국어점수, 영어점수, 수학점수를 입력받아
- 이름과 총점을 출력하는 프로그램을 구현한다.

Test017.java
- 자바의 기본 입출력 : System.int.read()
  BufferedReader의 readLine()과 비교!

System.in.read() 메소드는 한 문자만 가져온다.
readLine() 처럼 문자열대기열에 있는거 가져오는 건 같음.
단 , 입력받은 하나의 문자를 문자 그대로 가져오는 것이 아니라
ASCII Code 값으로 반환한다.
즉, 'A'를 입력하면 65로 가져온다! int형으로 변환해서 가져옴!!

-System.in.skip(매개변수);
 매개변수만큼 안읽고 건너 뛴다.
 엔터 == \r + \n

Test018.java
-printf() , format() 
-양수 강조법 : %+d
               %-d → 런타임에러 발생.
-음수 강조법 : -%d
- //System.out.printf("%d\n",'A');
		//처리가 아니라 표현이니까 아스키문자 - int 아니야
- 'A'는 char형이라 %c 해야함.
- 저렇게 쓰면 런타임 에러뜸!!
-%c 문자형, %s는 문자열형

//HEX 16진수로 바꿔서
//DEC 10진수
//OCT 8진수
//BIN 2진수
System.out.printf("%h\n", 365);
                    d
                    0
                    b
System.out.printf("%8.2f\n", 123.236);
		//  123.24
		//dot도 자리 하나
		// 앞에 두 자리
-    -    -    -    -    -    -    -
          1    2    3    .    2    4
		System.out.printf("%2.2f\n",123.236);
		//123.24 
		//쟤가 준 자리수가 우리자루에 비해 적으면
		//걍 무시깜

		System.out.printf("%3d\n",1231313);
		//1231313
		//int도 마찬가지

Test019.java
-자바의 기본 입출력 : java.util.Scaaner
※ java.util.Scanner
	 단락 문자 패턴을 사용하여 입력을 토큰에 따라 분할하며
   디폴트(default)로 사용되는 단락문자는 공백이다.
   작성된 다음 토큰은 『next()』 메소드를 사용
   다른 형태(자료형)의 값으로 변환할 수 있다.
- Scanner는 BufferedReader의 통역기(InputStreaReader)가 없어도 됨!
- IOException 없어도 됩니다. 인증받은 새끼임.

-sc.next()는 br.readLine()과 같은놈.
단, Integer.parseInt같은거 하지마.
    nextInt()가 있지롱
    별도의 형변환과정이 필요없습니다.

Test020.java
-import 안하고
- 매번 java.util.Scanner sc = new java.util.Scanner(System.in);
  가능하긴한데 할거임? 개귀찮음.

-scanner 공백 구분이 defalt임.
- 스페이스 무한해도 공백 한개로 인지
- 엔터도 공백으로 인지
- 입력값이 부족하면 당연히 안넘어가고 
- 많으면 뒤로 무시함.

Test021.java
// System.out.println("\"); -->컴파일에러
   애초에 저게 안됨. 뒤에 닫는 " 이거 써도 앵 \다음머임??
   하면서 계~속 문자열로 생각.
// 왜냐면 자바는 \이거 보고 아 ~ \s ? \d? 이러고 있음.
// 그래서 \이거 문자로 쓰고 싶으면 \\두개~
sc = new Scanner(sc.next()).useDelimiter("\\s*,\\s*");
이제 배우니까 알겠다.
sc를 초기화함. sc덮어쓰기함. 
sc = new Scanner(sc.next()).useDelimiter("\\s*,\\s*");
                            -------------
                             사용 구분자
                                         ------------
                                         모든문자열,모든문자열

→ 즉, 문자열을 콤마로 구분할게!

Test022.java
-실수형 데이터타입의 정밀도 테스트 실습
float보다 double이 정밀도가 높다. 십만번 반복했을때 값이 미세하게 다름으로 증명
→ 고로 실수는 double써라~

Test023.java
-산술 연산자
- 사용자로부터 임의의 정수를 두 번입력받아(한자리 아니여도됨)
- 사칙연산 및 나머지 연산을 수행하여 
- 그 결과를 출력하는 프로그램을 구현.
  
  문자열안에서 %를 표현하려면 "%%" 두번 쓰면 된다~!

Test024.java
- 비트 단위 연산자
  초급 개발자와 고급개발자의 차이는 비트연산자이다~
- 비트낫 == 1의 보수, 비트열반전
- 음수는 바로 2진수 계산 할 수 없다.
- 그래서 더해서 0이 되는 10진수 → 2진수로 바꾼 뒤 
   → 1의 보수를 취한뒤 + 1 을 한 값이 음수의 2진수이다.

Test025.java
- 비트and, 비트or,         비트xor
  둘다 t   둘중하나라도 t  둘이 다르면 t

Test026.java
// 비트 단위 연산자 『xor』 연산자를 활용하여
// 두 변수에 담겨잇는 내용(값) 바꾸기
x = x^y;
y = y^x;
x = x^y;

Test027.java
- shift !!! 존나 어려움.
<< 3: ← 이쪽으로 3움직여라. 뒤에는 0으로 채움
>>>3: → 이쪽으로 3움직여라. 앞에는 0으로 채움
>> 3: → 이쪽으로 3움직여라. 단, 앞에는 1로 채움 :  이거 부호변하는거방지!

Test028.java
- 논리연산자
논리and, 논리or, ! →  둘다 참, 둘 중하나 참!, 논리부정
cf ) ~ : 이건 비트부정~ 비트낫~ 1의보수 ~ 비트열반전~

Test029.java
-삼항 연산자 == 조건 연산자
 피연산자 연산자 피연산자 연산자 피연산자
 -------         --------        --------
   1항              2항             3항

  피연산자 ? 피연산자 : 피연산자
  -------    --------   --------
    1항        2항         3항

 1항의 연산 결과 → true  → 2항 수행
 		 → false → 3항 수행

Test030.java
- 사용자로부터 임의의 정수를 입력받아
  입력받은 정수가 양수인지, 음수인지, 0인지 구분하는
  프로그램 구현

Test031.java
-실행 흐름의 컨트롤(제어문)
-if ~ else
//사용자로부터 임의의 문자를 하나 입력받아
//대문자이면 소문자로 소문자이면 대문자로
//알파벳이 아닌 기타문자이면 입력오류 처리하는 프로그램을 구현

-boolean은 자동형변환 대상이 아닙니다. 
 그래서 명시적형변환도 안됩니다!

Test032.java
-사용자로부터 임의의 연도를 입력받아
 윤년인지 평년인지 판별하여
 결과를 출력하는 프로그램을 구현하라.

- 윤년 조건
  4의 배수이고 100의 배수가 아니다
  혹은 400의 배수이면 윤년이다.

Test033.java
//1. 프로그램을 작성할 때 주어진 조건에 따라
//   분기 방향을 정하기 위해 사용하는 제어문에는
//   if문, if~else문, 조건연산자, 복합if문(if문 중첩),
//   switch 문이 있다.

//2. if문은 if 다음의 조건이 참일 경우,
//   특정 문장을 수행하고자 할 때 사용되는 구문이다.

Test034.java
-if ~ else 실습

Test035.java
-if ~ else 실습, 홀수,짝수,0
-else에서 result를 출력할 때, 초기화를 하지않으면
 자바는 영짝홀 아닐 때, result가 뭔데~ 해서 컴파일에러발생!
// ※ if ~ else 구문의 중첩 구문은
//	  반드시 else로 끝나야 하는 것이 아니다.
//	  다만, 출력해야 할 구문을 처리하는 과정에서
//	  문제가 발생하지 않는 구문으로 작성해야 한다.


// ※ 조건문 구성 과정에서 이외의 영역(else)을
//    업무에 포함된 내용으로 처리하는 것은 바람직하지 않을 경우가 있다.
//    불가능한 경우는 어쩔 수 없더라도
//    가급적이면 업무에 포함되지 않는 내용을
//    이외의 영역(else)에서 처리할 수 있도록 하자.
// ex)주민번호, 010 등

Test036.java
-if ~ else 실습
// 사용자로부터 임의의 정수를 입력받아
// 다음과 같은 판별 결과를 출력하는 프로그램을 구현한다.

// 2의 배수 / 3의 배수 / 2와 3의 배수 / 2와 3의 배수 아님

Test037.java	과제
-if ~ else 실습
//사용자로부터 임의의 연도를 입력받아
//입력받은 연도가... 윤년인지 평년인지 판별하여
//그 결과를 출력하는 프로그램을 구현한다.
//단, 입력은 BufferedReader의 readLine()을 활용하고
//if 조건문을 활용하여 연산을 수행할 수 있도록 한다.

Test038.java
//사용자로부터 임의의 두 정수와 연산자를 입력받아
// 해당 연산자의 연산 처리 결과를 출력하는 프로그램을 구현해라.
// 단, if 조건문을 활용하여 처리할 수 있도록 하며,
// 연산 결과는 편의상 정수 기반으로 처리될 수 있도록 한다.

// 실행 예 )
// 첫 번째 정수 입력 : 
// 두 번째 정수 입력 : 
// 연산자 입력 [+ - * /] :

Test039.java
// 사용자로부터 임의의 정수 세개를 입력받아
// 작은 수에서 큰 수 순으로 출력하는 프로그램을 구현한다.

// 실행 예)
// 첫 번째 정수 입력 : 7
// 두 번째 정수 입력 : 70
// 세 번째 정수 입력 : 42

// >> 정렬 결과 : 7 42 70
// 계속하려면 아무 키나 누르세요 .....
// (1) 첫 번째 vs 두 번째
//		→ 첫 번째 정수 > 두 번째 정수보다 클 경우 자리 바꿈.
// (2) 첫 번째 vs 세 번째
//		→ 첫 번째 정수 > 세 번째 정수보다 클 경우 자리 바꿈
// (3) 두 번째 vs 세 번째
//		→ 두 번째 정수 > 세 번째 정수보다 클 경우 자리 바꿈.

- 나중에 쓴건데 max라는 변수에 담아서 실행하는 법도 있다.

Test040.java
// 사용자로부터 임의의 정수 5개를 입력받아
// 짝수별, 홀수별 합계를 출력하는 프로그램을 구현한다.
// 단, Scanner를 활용하여 데이터를 입력받을 수 있도록 한다.

// 실행 예 )
// 임의의 정수 5개 입력 : 1 2 3 4 5

// >> 짝수의 합은 6이고, 홀수의 합은 9 입니다.
// 계속하려면 아무 키나....

-누적합은 초기화 0부터
-누적곱은 초기화 1부터!

Test041.java	과제
-if ~ else 실습
//if ~else 

//  사용자로부터 임의의 알파벳 한 문자를 입력받아
//  이를 판별하여 입력받은 알파벳이 모음일 경우만
//  결과를 출력하는 프로그램을 구현한다.
//  단, 대소문자를 모두 적용할 수 있도록 처리한다.
//  또한, 알파벳 이외의 문자가 입력되었을 경우
// 입력 오류에 대한 내용을 사용자에게 안내해 줄 수 있도록 한다.

// 실행 예 )
// 임의의 알파벳 한 문자 입력 : A
// >> 모음 OK ~!!!
// 계속하려면 아무 키나...

// 임의의 알파벳 한 문자 입력 : e
// >> 모음 OK ~!!!
// 계속하려면 아무 키나...

// 임의의 알파벳 한 문자 입력 : B
// 계속하려면 아무 키나...

// 임의의 알파벳 한 문자 입력 : 1
// >> 입력 오류 ~!!!
// 계속하려면 아무 키나...

Test042.java	과제
//사용자로부터 임의의 문자를 하나 입력받아
//대문자이면 소문자로 소문자이면 대문자로
//알파벳이 아닌 기타문자이면 입력오류 처리하는 프로그램을 구현한다.


// 실행 예)
// 한 문자 입력 : A
// A → a
//계속하려면 아무 키나 누르세요....


// 한 문자 입력 : b
// b → B
//계속하려면 아무 키나 누르세요....

// 한 문자 입력 : 7
// >> 입력 오류 ~!!!
//계속하려면 아무 키나 누르세요....

Test043.java
-switch 실습
// switch 문 실습

/*
○ 다중 선택문이라 하며. switch 문 다음의 수식 값에
   따라 실행 순서를 여러 방향으로 분기할 때 사용하는
   문장이다.

○ 형식 및 구조
   switch(수식)
   {
	   case 상수1 : 문장1; [break;]		break 멈추고 (빠져나간다.)
	   									continue (뒷부분 무시하고) 계속해라
	   case 상수2 : 문장2; [break;]
	       :              :
	   [default : 문장n+1; [break;]]		//[]는 생략가능!
	}										//if문에 else랑 비슷
											//반드시 디폴트 ㄴㄴ
											//처리영역에서는 가능
											// 출력에서 에러날수는 있음.

	switch 문의 『수식』과 case의 『상수』는
	byte, short, int, long 형이어야 한다.
	//정수형태의 프리미티브형식만

	case 문 뒤에 『break;』가 없는 형태인 경우
	다음 case 문의 문장을 계속해서(이어서) 수행하게 된다. → (기본모델)
	『break;』가 존재할 경우
	해당 지점에서 수행을 멈춘 후 switch 문을 빠져나간다. → (일반모델)

Test044.java
-switch 실습
// 사용자로부터 1부터 3까지의 정수 중 하나를 입력받아
// 입력받은 정수만큼의 별문자(★)가 출력되는 프로그램을 작성한다.
// 단, 두 가지 방법으로 구현할 수 있도록 한다.

//① switch 문의 일반 모델을 사용한다.
//② switch 문의 기본 모델을 사용하되,
//   『break』를 딱 한 번만 사용할 수 있도록 구성한다.

// 실행 예)
// 임의의 정수 입력(1~3) : 3
// ★★★
// 계속하려면 아무 키나...

// 임의의 정수 입력(1~3) : 1
// ★ 
// 계속하려면 아무 키나...

// 임의의 정수 입력(1~3) : 7
// 입력 오류 ~ !!
// 계속하려면 아무 키나...

-누적을 이용하자!

Test045.java
// 사용자로부터 임의의 두 정수와 연산자를 입력받아
// 해당 연산자의 처리 결과를 출력하는 프로그램을 구현하라.
// 단, switch 문을 활용하여 처리할 수 있도록 하며
// 연산 결과는 편의상 정수 형태로 처리할 수 있도록 한다.

// 실행 예)
// 첫 번째 정수 입력 : 3
// 두 번째 정수 입력 : 17
// 연산자 입력 [+ - * /] : -

// >> 3 - 17 = -14
// 계속 ..............

Test046.java
- 반복문 실습
○ 반복문의 개요
	
	주어진 조건이 『참』인 경우
	일정한 영역의 문장을 반복 수행하다가
	조건식이 거짓이 되는 순간이 오면,
	반복 수행을 중단하는 문장이다.
	이러한 반복문에는 『while』, 『do ~ while』,『for』문 등이 있으며
	반복문의 제어를 위해 『break』,『continue』문을
	사용하는 경우가 있다.

○ while 문

	조건식을 먼저 비교하여
	조건식의 처리 결과가 참인 경우, 특정 영역을 반복 수행하는 문장으로
	반복 횟수가 정해져 있지 않은 경우나
	반복 횟수가 많은 경우 주로 사용한다.
	while 문은 조건이 맞지 않은 경우
	반복은 커녕 단 한 번도 실행되지 않을 수 있다.

○ while 문의 형식 및 구조

	while(조건식)
	{
		실행문;
	}
☆ 문제 1부터 100까지의 합을 계산하여
   결과 출력하는 프로그램을 구현한다.
   단 , while 반복문을 사용한다.

   실행 예 )
   1부터 100까지의 합: 5050
   계속하려면 아무 키나.......

※ 문제 인식 및 분석
	1. 출력 구문이 반복문의 영역 밖에 위치해야 한다.
	2. 1부터 1씩 증가할 변수와 누적합을 담을 변수
	   두 개의 변수가 필요하다.

Test047.java
-반복문(while)실습
//1부터 100까지의 정수 중에서 
//짝수들의 합을 계산하여 결과값을 출력하는 프로그램을 구현하라.
// 단, 조건문을 사용하지 않도록 하며,
// while 반복문을 활용하여 작성할 수 있도록 한다.

// 실행 예)
// 1부터 100까지의 정수 중 짝수의 합 : xxxx
// 계속 .........


//※ 문제 인식 및 분석
// 2+ 4+ 6+ 8 + ... + 100
//	- 초기값 : 2
//	- 증가값 : 2
//  - 한계값 : 100

Test048.java
-반복문(while)실습
//1부터 100까지의 정수 중에서
//짝수들의 합과 홀수들의 합을 따로 구분하여 계산한다.
// 단, 반복문은 while 문을 사용할 수 있도록 하며,
// 조건 구문은 if 조건문을 사용하여 작성할 수 있도록 한다.

// 실행 예 )
// 1부터 100까지의 정수 중
// 짝수의 합 : 2550
// 홀수의 합 : 2550
//계속 ............

Test049.java
-반복문(while)실습
//실행 예 )
// 1 부터 100 까지 정수의 합은 : 5050
// 1 부터 100 까지 짝수의 합은 : 2550
// 1 부터 100 까지 홀수의 합은 : 2500
//계속 ............

Test50.java
-반복문(while)실습
//1부터 100까지 정수의 합을 구하되,
//10의 배수가 될 때 마다... 결과를 출력하는 프로그램을 구현하라.

// 실행 예 )
// 1~10 까지의 합:
// 1~20 까지의 합:
// 1~30 까지의 합:
//	    :	
//1~100까지의 합 : 
//계속 .............

Test051.java
-반복문(while)실습
-n/n+1 + n+1/n+2 + ... + n+8 / n+9 의 연산 처리 결과를 출력하는 프로그램을 구현.

Test052.java
//반복문(while 문) 실습
//1 * 2 * 3 * ...* 9 * 10
-누적곱은 1로 초기화.

Test053.java
-반복문(while)실습
//사용자로부터 임의의 정수를 입력받아
//입력받은 정수가 소수인지 아닌지를 판별하여
//결과를 출력하는 프로그램을 구현한다.
※ 소수 : 1 또는 자기 자신의 값 이외에 어떤 수로도 나누어 떨어지지 않는 수.
//		     단, 1 은 소수 아님.

Test054.java

-반복문(while)실습
// 사용자로부터 임의의 두 정수를 입력받아
// 작은 수부터 큰 수 까지의 합을 구하여
// 결과를 출력하는 프로그램을 구현한다.

// 실행 예)
// 첫 번째 정수 입력 : 10
// 두 번째 정수 입력 : 20 
// >> 10 ~ 20 까지의 합은 : xxxx
// 계속하려면 ........

// 첫 번째 정수 입력 : 10
// 두 번째 정수 입력 : 2 
// >> 2 ~ 10 까지의 합은 : xxxx
// 계속하려면 ........

Test055.java	과제
-반복문(while)실습
//   사용자로부터 임의의 정수를 입력받아
//   1부터 입력받은 그 정수까지의
//   전체 합과, 짝수의 합과 , 홀수의 합을 
//   각각 결과값으로 출력하는 프로그램을 구현한다.


Test056.java
-반복문(while)실습
//사용자로부터 원하는 단(구구단)을 입력받아
//해당하는 구구단을 출력하는 프로그램을 구현한다.
// 단, 1단 ~ 9단 사이의 수를 입력받은 상황이 아니라면
// 이에 대한 안내를 한 후 프로그램을 종료할 수 있도록 처리한다.
//실행 예 )
//원하는 단(구구단) 입력 : 7
//7 * 1 = 7
//7 * 2 = 14
//7 * 3 = 21
//    :
//7 * 9 = 63
//계속하려면 아무 키나 .......

//원하는 단(구구단) 입력 : 11
//1부터 9까지의 정수만 입력이 가능합니다.
//계속하려면 아무 키나 .......
return; → 프로그램 종료, main()함수 종료.


Test057.java
-반복문(do ~ while)실습
○ 개요
	『do ~ while』문은 『while』문과 마찬가지로
	특정한 영역을 반복 수행하는 반복문이다.
	다만 『while』문과 다른 점은
	조건식에 대한 검사를 반복문을 수행한 이후에 한다는 것이다.
	이와 같은 성격으로 인해 반드시 한 번은 수행하게 되는 특징을 갖는다.

○ 형식 및 구조
  
	do 
	{
		실행문;
	}
	while(조건식);

// do ~ while 문의 활용 모델
// 예를 들어... 사용자로부터 특정 범위의 정수가 입력될 때 까지
// 입력받은 행위 자체를 반복해서 수행해야 하는 상황이라 가정한다.

//즉, 최소 한 번은 사용자의 입력값을 받아오는 처리를 수행해야
//반복을 추가로 수행할지 말지의 여부를 결정할 수 있는 상황이다.


Test058.java


-반복문(do ~ while 문) 실습

// 사용자로부터 여러 개의 양의 정수를 입력받고,
// 그 합을 계산하여 출력하는 프로그램을 작성한다.

// 단, -1이 입력되는 순간
// 입력을 중지하고 그동안 입력된 정수의 합을 출력해주는 프로그램을 구현한다.
// 즉, 『-1』을 입력 중지 커맨드로 활용한다.
// do ~ while 문을 활용하여 문제를 해결할 수 있도록 한다.



// 실행 예 )
// 정수1 입력 : 10
// 정수2 입력 : 5
// 정수3 입력 : 8
// 정수4 입력 : 9
// 정수5 입력 : -1

// >> 현재까지 입력된 정수의 합 : xxxx
// 계속하려면 .............

Test059.java
-반복문(do ~ while 문) 실습

○ 개요

    『for』문은 정해진 횟수만큼 반복해야 하는 경우
	유용하게 사용되어지는 반복문으로
	『while』문과 마찬가지로 반복 실행해야 하는 구문이
	조건에 맞지 않을 경우 한 번도 수행하지 않을 수 있으며
	루프 변수의 초기값, 조건식, 증감식 등을 한 지점에서 확인할 수 있기 때문에
	가독성이 높은 반복문에 해당한다.

○ 형식 및 구조
	
	for (수식1; 수식2; 수식3)
	{
		실행문;
	}

	수식1은 루프 변수의 초기화를 위해 사용되며,
		    최초 단 한번만 실행된다.
	수식2는 조건식을 나타내는 것으로 이 조건식(수식2)이 만족하면
	        루프를 반복해서 수행하게 된다.
			『for』문의 진행 순서는 수식2가 참이면 반복문을 수행하고
			수식3을 실행한 후 수식2의 조건식을 다시 검사하는 구조로 진행된다.
			따라서 처음에 조건식의 처리 결과가 거짓일 경우
			『for』루프를 한 번도 수행하지 않게 되는 것이다.
	수식3은 루프 변수의 재초기화를 위해 사용되어지며,
		    반복문의 조건식을 무너뜨리게 되는 증감식으로 처리하는 것이 일반적이다.
			컴마(『,』를 이용하여 여러 문장을 동시에 수행할 수도 있다.

수식2를 제외하고는 콤마가 사용가능하다!


Test060.java

-반복문(for 문) 실습


//1부터 100까지의 정수 중에서
//4의 배수만 출력하는 프로그램을 구현한다.
//단 for문을 활용해야 하며
//한 줄에 5개씩만 출력할 수 있도록 한다.


//실행 예 )
// 4	8	12	16	20
//24	28	32	36	40
//			:
//			:
//계속하려면 아무 키나 누르세요.....



Test061.java
-반복문(for 문) 실습

//다중 for문(반복문의 중첩)을 활용한 구구단 출력 실습

//실행 예)
/*
[2단]
2 * 1 = 2
2 * 2 =4
	:
2 * 9 = 18

[3단]
  :
9 * 9 = 81
// 계속하려면..........
*/

Test062.java
-반복문(for 문) 실습
//다중 for문(반복문의 중첩)을 활용한 구구단 출력 실습

//① 2중첩 *2		//②3중첩 *1


// 실행 예)
/*

2 * 1 = 2               3 * 1 = 3               4 * 1 = 4               5 * 1 = 5
2 * 2 = 4               3 * 2 = 6               4 * 2 = 8               5 * 2 = 10
2 * 3 = 6               3 * 3 = 9               4 * 3 = 12              5 * 3 = 15
2 * 4 = 8               3 * 4 = 12              4 * 4 = 16              5 * 4 = 20
2 * 5 = 10              3 * 5 = 15              4 * 5 = 20              5 * 5 = 25				→→→ 1문단
2 * 6 = 12              3 * 6 = 18              4 * 6 = 24              5 * 6 = 30
2 * 7 = 14              3 * 7 = 21              4 * 7 = 28              5 * 7 = 35
2 * 8 = 16              3 * 8 = 24              4 * 8 = 32              5 * 8 = 40
2 * 9 = 18              3 * 9 = 27              4 * 9 = 36              5 * 9 = 45

6 * 1 = 6               7 * 1 = 7               8 * 1 = 8               9 * 1 = 9
6 * 2 = 12              7 * 2 = 14              8 * 2 = 16              9 * 2 = 18
6 * 3 = 18              7 * 3 = 21              8 * 3 = 24              9 * 3 = 27
6 * 4 = 24              7 * 4 = 28              8 * 4 = 32              9 * 4 = 36
6 * 5 = 30              7 * 5 = 35              8 * 5 = 40              9 * 5 = 45				→→→ 2문단
6 * 6 = 36              7 * 6 = 42              8 * 6 = 48              9 * 6 = 54
6 * 7 = 42              7 * 7 = 49              8 * 7 = 56              9 * 7 = 63
6 * 8 = 48              7 * 8 = 56              8 * 8 = 64              9 * 8 = 72
6 * 9 = 54              7 * 9 = 63              8 * 9 = 72              9 * 9 = 81
계속하려면 아무 키나 누르십시오 . . .

//1. Test061과 비교하여
//출력의 방향이 다르기 때문에
//반복문의 제어 흐름도 달라져야 한다.
//콘솔기반의 출력환경이기 때문에..

//2.(1)에따라
//단과 곱해지는 수의 위치가
//달라진 상태에서 반복문 구성

//3.(2)에서 처리한 결과를 
//두 문단으로 반복하는 반복문 구성
//check~!!!! 반복문에 2의 결과를 삽입

//4.같은 구문을 
//두 문단으로 나누어 처리하는 과정에서
//문단에 따라 주어진 환경 (h의 값)을 활용하는 방법으로
//최종 반복문 3중첩.

Test063.java	과제
-반복문(for 문) 실습
//◎ 과제
//   다음과 같은 내용이 출력될 수 있도록
//   반복문의 중첩 구문을 작성하여 프로그램을 구현한다.

/* 실행 예)
    *	→ 공백 4 별 1    
   **   → 공백 3 별 2
  ***   
 ****
*****
*/

Test064.java	과제
-반복문(for 문) 실습
//다중 for문(반복문의 중첩)을 활용한 별찍기 실습

//◎ 과제
//   다음과 같은 내용이 출력될 수 있도록
//   반복문의 중첩 구문을 작성하여 프로그램을 구현한다.

/* 실행 예)  

    *
   ***
  *****
 *******
*********
*/

Test065.java	과제
-반복문(for 문) 실습
//다중 for문(반복문의 중첩)을 활용한 별찍기 실습

//◎ 과제
//   다음과 같은 내용이 출력될 수 있도록
//   반복문의 중첩 구문을 작성하여 프로그램을 구현한다.

/* 실행 예)

*********
 *******
  *****
   ***
    *
*/

Test066.java	과제
-반복문(for 문) 실습
//다중 for문(반복문의 중첩)을 활용한 별찍기 실습

//◎ 과제
//   다음과 같은 내용이 출력될 수 있도록
//   반복문의 중첩 구문을 작성하여 프로그램을 구현한다.

/* 실행 예)

    *   
   ***  
  ***** 
 *******
*********
 *******
  ***** 
   ***  
    *   
*/

Test067.java
-break 실습
// 다음과 같은 처리가 이루어지는 프로그램을 구현한다.
// 단, 입력받는 정수는 1 ~100 범위 안에서만
// 가능하도록 작성한다.

// 실행 예)
// 임의의 정수 입력 : -10

// 임의의 정수 입력 : 0

// 임의의 정수 입력 : 2022

// 임의의 정수 입력 : 10
// >> 1 ~ 10 까지의 합 : 55
// 계속하시겠습니까?(Y/N)? : y

// 임의의 정수 입력 : 100
// >> 1 ~ 100 까지의 합 : 5050
// 계속하시겠습니까?(Y/N) : N
// 계속하려면 아무 키나 누르세요 ... → 프로그램 종료.
br.reaLine()은 문자열을 받아옴! 
System.in.read()는 아스키코드를 받아옴!! 
엔터 = \r + \n입니다.
System.in.skip(2); : 대기열 엔터 스킵!!
※ break
반복문 멈추고 빠져 나가라 ~ 
가장 가까운 반복문을 빠져나간다!!
cf) continue
뒷 부분 무시하고 계속해라~~ 
→ 얘는 반복문의 처음으로 돌아갑니다! 반복문을 끝낼 수가 없어요 ~!!


Test068.java
-continue 실습

//continue 를 활용하여
// 다음과 같이 출력될 수 있도록 프로그램을 구현한다.
// 실행 예)

/*
1 : 1
3 : 4
5 : 9
7 : 16
  :
  :
  :
99: 2500
계속하려면 아무 키나 누르세요....

Test069.java
-return 실습

// ※ return 키워드가 지니는 두 가지 의미
//    ① 『값의 반환.』 return을 포함하고 있는 메소드에서 
//       지점에 값을 두고 온다..
//		  return + 무엇을 → 이런 형식


//    ② 『메소드 종료.』 return을 포함하고 있는 메소드 종료.
//        지금은 main()만 정의 중 → 프로그램 종료.
//        return; 단일.

Test070.java
-지역변수와 전역변수
// 지역 변수의 초기화 테스트

//Test071.java와 비교
// ※ 지역 변수는 초기화 과정을 거치지 않으면 사용할 수 없다.
//    자바가 자동으로 초기화를 수행해 주거나 하지 않는다.

//클래스의 영역에서 선언한 변수 == 전역 변수 == 글로벌변수
	// 클래스 변수 != 전역 변수
	// 클래스 변수 따로 있음
	public static void main(String[] args)
	{
		//메소드의 영역에서 선언한 변수 == 지역 변수 == 로컬변수
		int n;
		// --선언 후 초기화 과정을 거치지 않은 상태.
		System.out.println("n + : " + n);
		// → 컴파일 에러 발생
		//variable n might not have been initialized
		// → 지역 변수 n에 접근하여 그 값을 출력하고자 하는 구문



Test071.java
-전역 변수의 초기화 테스트
-전역변수는 클래스의 영역에서 선언됨.
- 인스턴스 생성해서 메모리에 올라감.
-자바가 자동으로 0으로 초기화합니다. 메모리에 올리면서 자동으로 설정.
- 자바는 메모리에 직접적인 접근을 허용하지 않는다.

Test072.java
-클래스와 인스턴스
// 직사각형 클래스 설계 실습

/*
직사각형의 넓이와 둘레 계산 → 클래스 표현

클래스의 정체성 → 직사각형
클래스의 속성   → 『가로,세로』, 넓이, 둘레, 부피, 무게, 재질, 색깔... 등
클래스의 기능   → 넓이 계산, 둘레 계산, 가로세로 입력, 결과 출력...등



객체를 구성     → 데이터(속성, 상태) + 기능(동작, 행위)
	↓
클래스를 설계   →		 변수         +      메소드

클래스 만들기 단계
① 변수 뭐하지?
② 메소드 뭐하지?
③ 메소드 매개변수 뭐하지?

클래스 설계도를 작성하면 인스턴스 생성을 먼저해야함

인스턴스 변수, 인스턴스 생성될 때, 메모리  할당받아요
멤버변수 == 전역변수 == 인스턴스 변수

반환자료형(반환되는 곳에 : 호출한 곳에 두고올거) 메소드명()
{
}
void는 출력만 합니다. 그 위치에 문자열 두고 오는게 아님.
// ※ 하나의 자바 파일 (.java)에 여러 개의 클래스(class)를 설계 할 수 있나???
// 	  : Yes
//    ★하지만, 『public class』는 하나만 올 수 있다.★
//    main()이 없는 java파일도 있다~
// 일반적으로는 하나의 파일에 하나의 클래스를 설계한다.
// 또한, 여러 개의 클래스가 설계된 파일을 컴파일하게 되면
// ★내부에 설계된 클래스의 수 만큼 클래스 파일(.class)이 파생된다.★

객체를 생성해야 메모리에 할당이 됩니다.

Test073.java
//※ CircleTest.java 파일과 세트 ~!!

// 원의 넓이와 둘레 구하기
// 원의 넓이와 둘레를 구할 수 있는 클래스를 설계한다.
// (클래스명 : CircleTest) → CircleTest.java
// BufferedReader의 readLine() 활용.

// 원의 넓이 = 반지름 * 반지름 * 3.141592
// 원의 둘레 = 반지름 * 2 * 3.141592

// 실행 예)
// 반지름 입력 : xx


// >> 반지름이 xx인 원의
// >> 넓이 : xx.xx
// >> 둘레 : xx.xx
// 계속하려면 아무 키나 누르세요....
import java.io.IOException;
//인스턴스 생성할때, import가 필요없는 이유는????????
// ▶▶▶▶▶▶▶▶ 물리적으로 같은 디렉토리안에 있어서

??? 클래스 기반 인스턴스 생성
??? 인스턴스 생성
??? 객체 생성

Test074.java

// 사용자로부터 임의의 정수를 입력받아
// 1 부터 입력받은 수 까지의 합을 연산하여
// 결과값을 출력하는 프로그램을 구현한다.

//단, 클래스와 인스턴스의 개념을 활용하여 처리할 수 있도록 한다.
// 또한, 입력 처리 과정에서 BufferedReader의 readLine()을 사용하며,
// 입력 데이터가 1보다 작거나 1000보다 큰 경우
// 다시 입력 받을 수 있는 처리를 포함하여 프로그램을 구현할 수 있도록 한다.

//실행 예)
//임의의 정수 입력 (1~1000) : 1050
//임의의 정수 입력 (1~1000) : -45
//임의의 정수 입력 (1~1000) : 100
// >> 1 ~ 100 까지의 합 : 5050
// 계속하려면 ............

생성한 인스턴스를 통해 입력 메소드 호출 
 : 참조변수 활용

Test075.java
// 사용자로부터 임의의 두 정수와 연산자를 입력받아
// 해당 연산을 수행하는 프로그램을 구현한다.
// 단, 클래스와 인스턴스의 개념을 활용하여 작성할 수 있도록 한다.

// 실행 예)
// 임의의 두 정수 입력 (공백 구분) : 10 5
// 임의의 연산자 입력 ( + - * /) : +
// >> 10 + 5 = 15
switch문에서 default : 경우의 수가 없으면 디폴트값..

Test076.java
-생성자(Constructor)

○ 생성자(Constructor)의 역할
 
   1. 인스턴스 생성 → 메모리 할당
   2. 초기화

○ 생성자(Constructor)의 특징

   1. 생성자는 메소드이지만, 일반 메소드처럼 호출될 수 없으며,
   							_______________
							자주 호출 불가
      반환 자료형을 가질 수 없다.
	  (『void』 조차 가질 수 없으며, 값을 반환할 수도 없다.)
	  return 있으면 안된다.

	2. 생성자는 클래스와 동일한 이름을 가져야 한다.
	   (대소문자 명확히 구분)
	
	3. 생성자는 객체를 생성하는 과정에서 『new생성자();』의 형태로 호출한다.
	   (인스턴스 생성 시 단 한 번만 호출)
	   __________________________________
	   이러한 특징 때문에 final 변수 초기화가 가능하다.

/*				 // ★ 사용자 정의 생성자가 존재하지 않을 경우
	NumberTest() // -- 컴파일 과정에서 자동으로 삽입되는 『디폴트 생성자』
				 //    (default Constructor)
				 //    클래스 이름과 같은 메소드를 만들어 주고
				 //    텅 비어있는 상태, 매개변수 없는 메소드.
				 //    눈에 보이지는 않지만.

전역변수는 자바가 0으로 초기화 해줌.
별도로 생성자 만들었다면 디폴트 생성자가 만들어지지 않는다.

Test077.java
-생성자(Constructor)
-사용자 정의 생성자가 있으면 디폴트 생성자가 자동으로 생성되지 않는다.
-사용자 정의 생성자에 매개변수가 필요하면
 생성자 () ← 이거 안에 매개변수 넣어야 컴파일 에러가 안뜬다!

Test078.java
-생성자(Constructor)
- 클래스에서 선언된 변수 멤버 변수, 인스턴스 변수 (static변수, 클래스 변수랑 다름)
	// 동일한 스코프안에서 동일한 메소드는 정의 안돼
	// 메소드가 식별가능해야하기 때문에.!

	// ※ 생성자의 이름은 항상 예외없이 클래스의 이름과 동일해야 하며
	//    필요할 경우 인수를 받아들이는 것도 가능하고
	//    같은 이름의 메소드를 정의하는 중복정의가 가능하지만
		→ 생성자 오버로딩이 가능하다.
                   생성자는 클래스안에서 최소 한개!
		   한 클래스는 반드시 하나 이상의 생성자를 가진다.
	//    리턴값 (반환값)은 가질 수 없다.


	// ※ 생성자는 다른 일반 메소드처럼 호출될 수 없고,
	//	  『new』 연산자를 이용하여 객체를 생성하기 위해 호출되며,
	//     각 클래스의 인스턴스인 객체를 생성한 후에
	//     생성된 객체의 멤버를 초기화시키는 작업을 수행한다.
인스턴스 생성 구문이 아닌데 
클래스 이름을 쓴다? → 고민해라. 
같은 클래스면 this를 써라. 클래스명을 대놓고 쓰지마라.
this가 쓰이면 이게 포함된 클래스를 찾아라.
this == class 명.

※ 생성자 안에서 생성자 호출이 가능할까요?

네. 가능합니다.
생성자 내부에서 다른 생성자를 호출하는 것은 가능하다.
하지만, 생성자 내부에서 가장 먼저 실행되어야 한다.!
이유랑 제한사항 꼭 기억해!
이유 : 다른생성자호출(100)이 일벌린걸 남은 걸로 해결하기 위해
제한사항 : 위쪽에. 먼저!!!

Test079.java
-생성자(Constructor)
-멤버변수는 초기화를 안해도 자바가 0으로 초기화 합니다!
-생성자 오버로딩

Test080.java
-생성자(Constructor)와 초기화 블럭(Initialized Block)
-멤버변수 선언하고 초기화 따로
int n;
n = 100;  → 불가합니다  error: <identifier> expected
             『=』는 대입연산자 입니다. 대입연산자? 오른쪽부터
    	     대입 연산자도 연산입니다 . 연산처리는 클래스안에서 ㄴㄴ
             메소드!!안에서만 가능!! 아무래도 상수에 대한 메모리할당이
	     안돼. 클래스가 객체생성전에는 메모리 할당이 안돼서 그런듯?

int n = 100; 이건 가능해요 선언과 동시에 초기화!

초기화 블럭(Initialized Block) 이란?
클래스안에서 멤버변수 선언하고 
{
	이 안에서 멤버변수를 초기화 할 수 있습니다!
}

생성자 vs 초기화블럭
초기화 블럭이 코드를 먼저 수행했다하더라도
최종적으로는 해당 멤버들의 초기화 값은 생성자가 결정.
초기화 블럭 실행 → 생성자 실행
초기화가 무슨 짓을 해도 생성자가 덮어씀!!!!!!!!!!!
생성자 내부에서 생성자를 호출하는 것두 같은 방법.
생성자 내부에서 생성자 호출하면 제일 먼저!!!!!!!!!!!!!!
             
Test081.java
-배열 선언과 초기화
○ 배열의 개요
   
   1. 배열이란?
      크기와 성격이 같은 일련의 원소들이 모여
	  공동의 집합 구조를 갖는 자료의 집합체를 의미하는 것으로
	  『동질적인 성격을 가진 자료들』에 대해
	  개별적으로 자료형(Data type)을 부여하지 않고
	  하나의 이름을 가지고 일괄적으로 처리할 목적으로 사용된다.

   2. 자바에서의 배열은 다음과 같은 순서에 의해 사용된다.
      배열 선언 → 배열에 메모리 할당 → 배열 요소 접근(배열 요소의 사용)


○ 형식 및 구조
   
   자료형[] 변수명; //[]생략가능 ㄴㄴ 문법적으로 쓰임.
   변수명 = new 자료형[요소크기]
   변수명[인덱스] = 값;

   int[] arr; == int a[]; (같음.)
   arr = new int[3];
   int [] arr == new int[3]; 
					// 인스턴스 생성이랑 비슷하게 생겼으니 헷갈 ㄴㄴ
					// 배열도 참조타입임. 주소가 담겨있음.

// 배열은 다음과 같이 선언과 동시에
		// 메모리 할당 및 초기화가 가능하다.
		int [] arr2 = new int[10];
		int [] arr3 = {1,2,3,4,5,6,7,8,9,0};
		int arr4 [] = {1,2,3,4,5,6,7,8,9,0};
//※ 값을 할당하지 않은 나머지 배열 공간은
		//   자동으로 초기화된다 → 0 (int형 배열)
int num = 10;
		System.out.println("num : " + num);
		// -- >> num : 10

		System.out.println("arr : " + arr);
		// -- >> arr : [I@15db9742
		//       메모리의 주소값을 의미하는 건 아님.
		//       배열을 출력하기 위해 배열변수를 일반 변수처럼 사용하여
		//       배열의 각 방에 들어있는 데이터가 출력되는 것이 아니라
		//       우리가 알아볼 수 없는 코드가 출력된다.
		//       (자바는 메모리 주소값에 사용자가 직접 접근하는 것을 허용하지 않기 때문에)

변수는 변수값이 그대로 담겨있고 배열은 참조주소가 담겨있다!
그래서 배열 값에 접근하려면 arr[0]이런식! 인덱스번호를 줘라!

Test082.java
// 배열의 기본적 활용

// 임의의 정수들이 들어있는 배열의 숫자 데이터들 중
// 짝수인 요소만 골라서 출력하고, 3의 배수인 요소만 골라서 출력하는
// 프로그램을 구현한다.
배열의 길이(방 갯수) 확인 : arr.length
arr의 변수임. 

Test083.java
// 배열의 선언과 초기화
// 배열의 기본적 활용

// 『char』 자료형의 배열을 만들어
// 그 배열의 각 방에 알파벳 대문자를 채우고
// 채워진 그 배열의 전체 요소를 출력하는 프로그램을 구현한다.
// 단, 채우는 구문과 출력하는 구문은 따로 분리하여 처리한다.

// 실행 예 )
// A B C D E F G H I ... W X Y Z
// 계속하려면 아무 키나 누르세요...
★반복문 안에 변수 1개아님!!
for(수식1;수식2;수식3)이면
수식1, 수식3에는 변수 여러개 가능합니다!

Test084.java
-배열의 선언과 초기화
// 배열의 기본적 활용

// 사용자로부터 인원수를 입력 받고
// 입력받은 인원 수 만큼의 학생 이름과 전화번호를 입력받고
// 이를 이름 배열과 전화번호 배열로 구성하여 
// 결과를 출력할 수 있는 프로그램을 구현한다.

// 실행 예)
// 입력 처리할 학생 수 입력(명, 1 ~ 10) : 27
// 입력 처리할 학생 수 입력(명, 1 ~ 10) : -5
// 입력 처리할 학생 수 입력(명, 1 ~ 10) : 3
// 이름 전화번호 입력[1](공백 구분) : 박현수 010-1111-1111
// 이름 전화번호 입력[2](공백 구분) : 신시은 010-2222-2222
// 이름 전화번호 입력[3](공백 구분) : 오이삭 010-3333-3333

//---------------------------------
// 전체 학생 수 : 3명
//---------------------------------
//이름		       전화번호
//박현수	       010-1111-1111
//신시은		   010-2222-2222
//오이삭		   010-3333-3333
//---------------------------------
//계속하려면 ................

do ~ while문에서
while문이 true면 반복혀라!!

Test085.java	과제
-배열의 기본적 활용

//   사용자로부터 임의의 정수를 임의의 갯수만큼 입력받아
//   입력받은 수 중에서 가장 큰 수를 출력하는 프로그램을 작성한다.
//   단, 배열을 활용하여 구현할 수 있도록 한다.

// 실행 예)
// 입력할 데이터의 갯수 : 12
// 데이터 입력 (공백 구분) : 74 65 13 91 5 67 33 41 2 50 11 38
// >> 가장 큰 수 → 91
// 계속하려면 아무 키나 누르세요...
가장 큰 수 구하기!
max변수를 arr[0]으로 주고 크기비교해서 max를 초기화해라!


Test086.java	과제
-배열의 기본적 활용

//   사용자로부터 임의의 학생 수를 입력받고
//   그만큼의 점수(정수 형태)를 입력받아
//   전체 학생 점수이 합, 평균, 편차를 구하여
//   결과를 출력하는 프로그램을 구현한다.
//   단, 배열을 활용하여 처리할 수 있도록 한다.

Test087.java
-배열의 배열(2차원 배열)
int arr [][] = new int [3][4];
[] [] [] [] ~ 웅웅 ↓↓↓↓ 숑숑이! 
[] [] [] [] ~
[] [] [] [] ~

Test088.java
-배열의 배열(2차원 배열)

// 배열의 배열(다차원 배열)을 활용하여
// 다음과 같은 데이터를 요소로 취하는 배열 (5 x 5)을 구성하고
// 그 결과를 출력하는 프로그램을 구현한다.

// 실행 예)
/*
 1  2  3  4  5
 6  7  8  9 10
11 12 13 14 15
16 18 18 19 20
21 22 23 24 25
int arr [][] = new int [5][5];
1부터 25까지 넣고 배열 전체 요소 출력 ㄱㄱ

Test089.java
-배열의 배열(2차원 배열)

// 실행 예)
/*
   1   2   3   4   5  
   2   3   4   5   6  
   3   4   5   6   7  
   4   5   6   7   8  
   5   6   7   8   9  

계속하려면 아무 키나 누르십시오 . . .
[5][6]만들고 두번째 웅웅이 보니까 1씩 커짐.

Test090.java♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥
-배열의 배열(2차원 배열)

// 배열의 배열(다차원 배열)을 활용하여
// 다음과 같은 데이터를 요소로 취하는 배열을 구성하고
// 그 결과를 출력하는 프로그램을 구현한다.

// 실행 예)
/*
   1   2   3   4   5   
   5   1   2   3   4   
   4   5   1   2   3   
   3   4   5   1   2  
   2   3   4   5   1   
출력 시작점을 확인!! 이거 존나 어려웠삼.

Test091.java♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥
-배열의 배열(2차원 배열)

// 배열의 배열(다차원 배열)을 활용하여
// 다음과 같은 데이터를 요소로 취하는 배열을 구성하고
// 그 결과를 출력하는 프로그램을 구현한다.

// 실행 예)
/*
   1   8   9    16   17   
   2   7   10   15   18   
   3   6   11   14   19   
   4   5   12   13   20     

계속하려면 아무 키나 누르십시오 . . .
시작점 확인!! 배열문제는 시작점을 확인해라!

Test092.java♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥
-배열의 배열(2차원 배열)

// 배열의 배열(다차원 배열)을 활용하여
// 다음과 같은 데이터를 요소로 취하는 배열을 구성하고
// 그 결과를 출력하는 프로그램을 구현한다.

// 실행 예)
/*
   E   J   O   T   Y
   D   I   N   S   X   
   C   H   M   R   W   
   B   G   L   Q   V   
   A   F   K   P   U     

계속하려면 아무 키나 누르십시오 . . .
역순!!!!!!!!!!!!!!!! 배열은 문제 종종 풀어보자잉

Test093.java♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥
-배열의 배열(2차원 배열)

// 배열의 배열(다차원 배열)을 활용하여
// 다음과 같은 데이터를 요소로 취하는 배열을 구성하고
// 그 결과를 출력하는 프로그램을 구현한다.

// 실행 예)
/*
   1   2   3   4   10
   5   6   7   8   26
   9  10  11  12   42
  13  14  15  16   58
  28  32  36  40  136

Test094.java	과제
- 배열의 배열(2차원 배열)

//   배열의 배열(다차원 배열)을 활용하여
//   다음과 같은 데이터를 요소로 취하는 배열을 구성하고
//   그 결과를 출력하는 프로그램을 구현한다.

// 실행 예)
/*
A  B  C  D  E
F  G  H  I  J
K  L  M  N  O
P  Q  R  S  T
U  V  W  X  Y

계속하려면 아무 키나 누르십시오 . . .

Test095.java	과제
-배열의 배열(2차원 배열)


//○ 과제
//   배열의 배열(다차원 배열)을 활용하여
//   다음과 같은 데이터를 요소로 취하는 배열을 구성하고
//   그 결과를 출력하는 프로그램을 구현한다.

// 실행 예)
/*
A
B  C
D  E  F
G  H  I  J
K  L  M  N  O

계속하려면 아무 키나 누르십시오 . . .

Test096.java	과제
-배열의 배열(2차원 배열)
//   배열의 배열(다차원 배열)을 활용하여
//   다음과 같은 데이터를 요소로 취하는 배열을 구성하고
//   그 결과를 출력하는 프로그램을 구현한다.

// 실행 예)
/*
A
C  B 
D  E  F
J  I  H  G 
K  L  M  N  O

계속하려면 아무 키나 누르십시오 . . .

Test097.java
-배열과 난수 처리(※ Random 클래스 활용)
//배열과 난수 처리(※ Random 클래스 활용)

//사용자로부터 임의의 정수를 입력받아
//그 정수의 갯수만큼 난수를 발생시켜 배열에 담고
//배열에 담겨있는 데이터들 중
//가장 큰 값과 가장 작은 값을 선택하여
//결과를 출력하는 프로그램을 구현한다.

//실행 예)
//발생시킬 난수의 갯수 입력 : 10
//50 7 24 81 72 45 61 38 1 99 
//가장 큰 값 : 99, 가장 작은 값 : 1
//계속하려면 .........

무작위 정수(난수) 발생하기 위해서는
난수 발생 전용 객체가 필요하다.
『java.util.Random』
랜덤 인스턴스 생성. // BufferedReader나 Scanner처럼이용.
Random rd = new Random();
Random 클래스의 『nextInt()』 메소드
0 ~ 매개변수로 넘겨받은 정수 n - 1까지의 수 중
무작위 정수(난수) 1개를 발생시킨다.
rd.nextInt(10) // 0 ~ 9
개수는 한개, 그 수의 범위가 0 ~ 9임.
다시 기억해라 개수는 1개이고 범위가 0~9인것.!
가장 큰값, 가장 작은 값은 배열 엉망되도 좋으니 자리바꾸기말고
초기화를이용해라!!!!!!!!!!!!

Test098.java
// 배열의 복사

// Test099.java 파일과 비교 ~!!!

// ※ 배열 변수의 복사에는 데이터 복사, 주소값 복사 두 가지 형태가 존재한다.

//    주소값 복사 → 얕은 복사 → 원본을 수정하면 복사본에 영향을 미치게 되는 복사 방법.
//                                (배열 뿐 아니라 모든 『참조형 데이터』에 해당하는 복사 방법.)

//    데이터 복사 → 깊은 복사 → 실제 요소로 들어있는 값에 대한 복사로
//                                원본을 수정해도 복사본에 영향으 미치지 않는 복사 방법.

// 주소값 복사
변수는 값타입입니다. 그래서 원본 바껴도 안바뀌고
배열은 배열전체를 복사하면 주소값복사(얕은 복사)가 되어
원본배열이 바뀌면 복사배열도 바뀝니다!!!!!!!!!!!!!!!

Test099.java
// 배열의 복사

//Test098.java 파일과 비교 ~!!!

// ※ 배열 변수의 복사에는 데이터 복사, 주소값 복사 두 가지 형태가 존재한다.

//    주소값 복사 → 얕은 복사 → 원본을 수정하면 복사본에 영향을 미치게 되는 복사 방법.
//                                (배열 뿐 아니라 모든 『참조형 데이터』에 해당하는 복사 방법.)

//    데이터 복사 → 깊은 복사 → 실제 요소로 들어있는 값에 대한 복사로
//                                원본을 수정해도 복사본에 영향으 미치지 않는 복사 방법.

// 데이터 복사
// - int 형 배열에 대한 깊은 의미의 복사를 처리하는
//   메소드를 정의하는 형태로 실습
프리미티브 자료형 복사처럼(값타입) 요소 하나하나를 복사해서 원본이 바뀌어도 
복사배열은 바뀌지 않음!
1. 배열은 객체이다.
2. 배열.length 사용이 가능하다. length는 객체가 가진 변수
3. 배열.clone(); 는 객체와 설계도 
4. 객체를 반환하는 자바가 제공한 메소드

원본배열의 요소를 하나하나 복사한다는 점이 주소값 복사랑 다른점!
요소 하나하나 값타입을 복사! 배열은 참조타입!

Test100.java
-정보 은닉과 접근 제어 지시자(접근지정자, 접근제한자...)
	// 정보 은닉(Information Hiing)
	// 멤버 변수,인스터스 변수 ,전역 변수
	// 『private』이라는 접근제어지시자의 선언은
	// 클래스 내부에서만 접근 및 참조가 가능하게 하겠다는 의미.
	// ↓ 
	// CircleTest2 의 멤버 변수 선언, 인스턴스 변수, 전역변수
	//int num;	//→ 인스턴스 생성 시, 메모리 할당 받음.
접근제어 지시자
=접근 지정자
=접근 제한자
=접근 제어자

public    : 모든 접근 허용

protected   : 

(default)   : 접근제어 지시자 안쓰면 디폴트

private   : 나혼자만 접근 허용 == 클래스 내부에서만 접근 및 참조가 가능하게 하겠다는 의미.

              ■■■접근제어 지시자의 관계■■■

지시자	 클래스 내부    동일패키지    상속받은 클래스    이외의 영역

private      O              X               X                X

default      O              O               X                X

protected    O              O               O                X

public       O              O               O                O

            <접근제어의 허용범위>
※ public > protected > defalt > private
   넓다                           좁다

①   접근제어 지시자를 아무것도 붙히지 않으면 default이다.

②   default vs protected 
     『상속받은 클래스』
     protected만 가능.

ex) public class Test000
    ______
    접근제어지시자

{
	public static void main(String[] args)
	{
		(default) int a;
		_________
		접근제어지시자
	}
}

Test101.java
-클래스 설계
-배열 활용
-접근제어지시자와 정보은닉


// 사용자로부터 년, 월, 일을 입력받아
// 해당 날짜의 요일을 출력하는 프로그램을 구현한다.
// 단, 달력 클래스(Calendar)는 사용하지 않는다.
// 또한, 클래스의 개념을 활용하여 작성할 수 있도록 한다. (→WeekDay 클래스 설계)
// 그리고, 배열의 개념도 적용시켜서 작성할 수 있도록 한다.
// 접근제어지시자의 개념도 확인하여 작성할 수 있도록 한다.
// 최종적으로 WeekDay 클래스 설계를 통해
// Test101 클래스의 main() 메소드가 정상적으로 프로그램 실행 될 수 있도록 한다.

// ※ 1년 1월 1일 → "월요일"

// 실행 예)
// 년 월 일 입력 (공백 구분) : 2022 1 19
// 2022년 1월 19일 → 수요일
// 계속하려면 아무 키나....

// 2000년 5월 4일 → 목요일
// 계속하려면 아무 키나....

Test102.java
-static 변수(클래스변수)와 static 메소드(클래스메소드)

// ※ 실습 편의상 접근제어 지시자 생략
	// ※ 클래스 변수 또는 클래스 메소드는
	//    클래스 정보가 로딩되는 순간 메모리 할당이 이루어지며
	//    클래스 이름 또는 객체(인스턴스)를 통해 접근할 수 있다.
	//           → 둘 다 가능하다는 소리. 
	//              클래스의 이름으로 접근하는 것이 일반적!

	//    즉, 『new』 연산자를 통해 메모리를 할당 받지 않아도
	//    사용이 가능하다는 것이다.
static변수(클래스변수, class변수, 정적변수)
초기화블럭 여기에도 static가능 나중에배움.
초기화 → 생성자() (우선순위 Test080.java)

// ※ 인스턴스 변수 또는 인스턴스 메소드는
	//    동일한 클래스의 메소드에서는 바로 접근하는 것이 가능하지만
	//         → 둘다 인스턴스 메소드라면 객체생성안해도 가능

	//    클래스 메소드에서는 접근할 수 없다.
		→ 탄생시점이 다르다. 인스턴스 변수는 객체 생성시에 
                   만들어짐.

non - static변수(인스턴스변수, instance변수,동적변수)
non - static메소드(인스턴스메소드, instance메소드 , 동적메소드)
인스턴스가 클래스를 부른다 가능! → 동생이 형을 부른다 가능
클래스메소드가 인스턴스 변수를 부른다 불가능!!! → 동생안태어남.
static끼리도 탄생시점이 같아서 부를 수 있다.

// 클래스 변수에 접근하기 위해서는
『클래스명.변수명』의 형태로 클래스의 이름을 통해
접근하는 것이 가능하다.
-->> main() → 클래스 변수 a : 10
Test102에 대한 인스턴스 생성안해도 가능.
클래스 변수라!

클래스명을 직접쓴다!!! static!!!! 그래서 this를 썼던거임~!
// 같은 클래스 내부의 메소드이기 때문에
-->> main() → 클래스 변수 a : 10
같은 클래스 내에서 부르면 클래스명 생략가능!
같은 클래스 내부에 존재하기 때문에
클래스 이름을 생략하는 것이 가능하다.

★ 같은 클래스 내부에서
   클래스 메소드 호출 ( static 메소드 호출)
   클래스명 생략 가능!
클래스 메소드에서 클래스 메소드의 호출은 가능하며,(main()에서 print())
『클래스명.메소드명()』의 형태로 접근하여 호출하는 것이 가능하다.
또한, 지금은 같은 클래스 내부에 존재하기 때문에
클래스의 이름을 생략하는 것이 가능하다.

인스턴스 변수는 생성된 인스턴스를 통해서만 접근이 가능하다.
static main()이 탄생한 순간, 인스턴스 변수는 탄생안한다.
클래스가 로딩되는 순간임!!!!!!!!!!!!!
→ 인스턴스변수든 메소드든 객체가 생성되어야 탄생한다
   main에서 인스턴스 변수, 메소드 호출 불가능
   형이 동생 부르기 불가능 동생 태어난지 몰라

 ※ 클래스 변수나 클래스 메소드는
    『생성된인스턴스명.변수명』 『생성된인스턴스명.메소드명()』 가능
    『클래스명.변수명』  『클래스명.메소드명()』 일반적임 가능

인스턴스 변수는 객체마다 다름.
클래스 변수는 한번 초기화 하면 다 같음!

클래스하면 "공유"와 "탄생시점"
스테이플러(공유) 딱풀(객체전용변수)

Test103.java
-클래스와 인스턴스 활용

// 학생별로 국어점수, 영어점수, 수학점수를 입력받아
// 총점, 평균을 계산하는 프로그램을 구현한다.
// 단, 클래스의 개념을 활용하여 작성할 수 있도록 한다.
// 또한, 이 과정에서 배열을 적극적으로 활용할 수 있도록 한다.
// 클래스 설계는 다음의 가이드라인에 따라 진행할 수 있도록 한다.

// 프로그램을 구성하는 클래스
// 1. Record 클래스
//    - 속성만 존재하는 클래스로 설계할 것 ~!!
//
// 2. Sungjuk 클래스
//    - 인원 수를 입력받아, 입력받은 인원 수 만큼
//    이름, 국어점수 영어점수, 수학점수를 입력받고
//    총점과 평균을 산출하는 클래스로 설계할 것 ~!!
//    속성 : 인원수, Record 형태의 배열
//    기능 : 인원수 입력, 상세 데이터 입력, 총점 및 평균 연산, 결과 출력
//
// 3. Test103 클래스
//    - main() 메소드가 존재하는 외부 클래스로 설계할 것~!!

한 java파일안에서 public은 하나! 왜냐하면 그걸로 자바파일 만들어져.
 인스턴스 생성 전에 다른 클래스에서 활용할거라 
						// static이 붙음!

같은 클래스는 인스턴스 생성 전에 활용가능합니다~!
클래스명.변수명으로 활용하자!
Record r1 = new Record(); 하면 r1객체 만듬.
Record형식의 객체 생성.
Record class에 데이터 변수가 있으면
Record.rank 이런식으로 활용가능
Test104.java
Test105.java
Test106.java
Test107.java
Test108.java
Test109.java
Test110.java
Test111.java
Test112.java
Test113.java
Test114.java
Test115.java
Test117.java

-상속(Inheritance)
※ 메소드 오버라이딩(Method Overriding)의 특정
   - 메소드 이름, 리턴타입, 파라미터 수나 타입이 완전히 일치해야 한다.
   - 반드시 상속 관계가 있어야 한다.
   - 재정의된 하위 클래스의 메소드 접근제어지시자는
     상위 클래스의 메소드 접근제어지시자보다 범위가 크거나 같아야 한다.
	 예를 들어, 상위 클래스 메소드의 접근제어지시자가 『protected』인 경우
	 하위 클래스가 이 메소드를 오버라이딩(Overriding)하는 경우
	 접근제어지시자는 『protected』 또는 『public』이어야 한다.
   - 『static』,『final』,『private』 메소드는 오버라이딩(Overriding)할 수 없다.
	  --------
	  이미 클래스가 생성되면서 만들어지고 메모리 잡아서
	  바꾸기 힘듬. 탄생시점이 다름

	              -------
				  상속에 있어서 상수화도 여전~

				  		    ---------
							오버라이딩 전제 조건 상속이 가능해야함.
							private는 상속자체가 불가능! 나만 접근 가능!

   
   - Exception의 추가가 불가능하다.
     즉, 상위 메소드가 가지고 있는 기존 예외 사항에
	 새로운 Exception을 추가하는 것은 불가능 하다는 것이다.
	 자바에서 Exception도 객체입니다! 



Test118.java
-상속 관계에 있는 클래스들 간의 캐스팅
- 업 캐스팅, 다운 캐스팅

상위 클래스 SuperTest118
하위 클래스 SubTest118

SUuperTest118 ob2; 
 → 놀라운 사실 이건 생성자가 없으니 가능합니다 에러 안떠요!!
 → SuperTest118타입으로 ob2이름의 변수를
    참조변수 형태로 쓸거라고 선언!!

cf) 참조변수
cf) 객체 생성자 (); 이때부터 메모리할당가능.

SubTest118 ob1 = new SubTest118();

SuperTest118 ob2 = ob1;
== 위아래같음! 자동형변환임. 작은걸(서브) 큰 그릇(슈퍼)에 담는다.
SuperTest118 ob2 = (SuperTest118)ob1;


확인 point
1. Overriding된 메소드는 덮어쓰기가 된거라
   다시 못돌아가!
   메소드랑 변수는 다름!!
   업캐스팅 되면 재정의한 이상 원래의 기능으로 못돌아가!!

2. 변수는 객체별로 따로 할당이 됩니다!
   그래서 클래스명.변수명 → 그 클래스의 변수가 출력
   메모리는 따로! 접근방식에 따라 변수에 따로 접근가능합니다
   → 값타입이니까

3. ob2.c 
   직접 클래스에 접근.
   c는 하위 클래스의 멤버 변수임으로 부모클래스에서는 안보여용

   대신 하위 클래스에서는 상위클래스 멤버변수가 보이지(상속받을 수 있는거면)

4.((SubTest118)ob2).print()
  → 부모에게 print()메소드 없어요
     다운캐스팅해서 하위 객체로 내려와서 print출력해요


상위 객체를 생성했을 때는
다운 캐스팅이 불가능하다.
슈퍼클래스를 통해서 자식클래스에 접근할 수 없다.   
하위 = 상위; //에러 발생.
하위 = (하위)상위; //다운 캐스팅. 런타임에러.


====가능====
1. 하위 객체 생성;	//-- check~!!!!!
2. 상위 = 하위;	// 업 캐스팅. 정상
3. 하위 = 상위; // 에러 발생. 자동형변환 문제 그래서 ↓
4. 하위 = (하위)상위; → 명시적	// 다운 캐스팅.정상



Test119.java
Test120.java
Test121.java
Test122.java
Test123.java

Test124.java
-중첩 클래스
-실무에서 적극적으로 쓰이진않아요
○ 중첩 클래스
   
   중첩 클래스란 클래스 안에 다른 클래스가 설계되어 있는 형태로
   클래스 내부에서만 사용할 보조 클래스가 필요한 경우
   클래스를 중첩하여 프로그램의 구조를 보다 더 간단하고 알아보기 쉽도록
   만들 수 있는데 이러한 클래스를 중첩 클래스라 한다.
   이는 특정 클래스를 자신의 클래스 내부적인 용도로만
   사용할 목적으로 쓰이는데
   특정 클래스를 마치 자신의 멤버 변수나 메소드처럼 사용할 수 있게 한다.

○ 중첩 클래스의 종류(4가지)
   
   1. static 중첩 클래스(중첩 내부 클래스)
      클래스 내부에... 『public static class 클래스명』

	  중첩 클래스를 감싸는 외부 클래스 {} 안에 
	  static 을 붙인 새로운 클래스를 설계하는 것으로
	  모든 접근제어지시자를 사용할 수 있다.
	  static 중첩 클래스가 포함하고 있는 메소드에서는
	  외부 클래스의 인스턴스 변수나 인스턴스 메소드에는 접근할 수 없고,
	  (외부 클래스의 객체를 생성하지 않은 상태)
	  클래스 변수와 클래스 메소드만 접근할 수 있다.

	  - 프로그램의 구조를 보다 더 간단하고 알아보기 쉽게 구성할 수 있다.
	  - static으로 선언된 내부 클래스 이다.
	  - 중첩 클래스의 객체는 중첩 클래스를 포함하고 있는
	    외부 클래스의 객체와 동등하다.
	  - 외부 클래스의 클래스 변수와 클래스 메소드는
	    바로 접근하여 사용하는 것이 가능하다.
	  - 중첩 클래스와 중첩 클래스를 포함하고 있는 외부 클래스의
	    인스턴스 변수와 인스턴스 메소드는
		객체를 생성하여 서로 접근하는 것이 가능하다.
      - 중첩 클래스를 외부에서 단독으로 사용하는 것이 가능하다.

   2. 내부 클래스(inner class)
      클래스 내부에... 『public class 클래스명』

	  - static 중첩 클래스와 마찬가지로 프로그램 구조를 보다 더 간단하고
	    알아보기 쉽도록 한다.
	  - 외부 클래스의 메소드에서 내부 멤버 클래스를 사용하기 위해서는
	    반드시 내부 멤버 클래스 객체를 생성해 주어야 한다.
	  - 외부 클래스의 멤버 변수와 메소드를
	    객체 생성 없이 바로 사용하는 것이 가능하다.
	  - 내부 멤버 클래스는 외부에서 단독으로 객체를 생성하여
	    사용할 수 없다.
	    즉, 내부 멤버 클래스는 외부 클래스의 인스턴스 생성이
		선행되어야 한다는 것이다.
	  - static 으로 선언된 변수 또는 메소드를 가질 수 없다.

   3. 지역 클래스(로컬 클래스 ,local class)
      메소드 내부에...『public class 클래스명』
	                or 『public static class 클래스명』

	  - 클래스의 메소드 안에서 클래스를 정의하는 것으로
	    내부 멤버 클래스와 유사한 성격을 가지고 있긴 하지만
		접근제어지시자는 붙일 수 없다.

   4. 무명 클래스(익명 클래스, annoymous class)★ 얜 쓰임.
      이름 없는 클래스

	  - 클래스 또는 인터페이스에 대한 객체를 생성하면서
	    바로 클래스 또는 인터페이스를 정의하는 클래스.
	  - 정의하는 부분과 생성하는 부분이 하나로 묶여져
	    new 수식이 있는 곳에서 바로 클래스
		또는 인터페이스를 정의하는 것을 의미한다.

		new
		{
			...
		};

→ 중첩된 클래스는 바깥 클래스만!!!!!!!!쓴다.
   객체는 여기저기 다 쓰일라하는건데 얜 요상해.
   
   모바일의 이벤트.. 각각 독립적인 객체로 설정하면
   넘 많아서 리소스 소모가 너무 커요.

무명 클래스(익명 클래스, annoymous class)
      이름 없는 클래스
	  (이름을 붙힌다 → 호출하고 제어하고 ..
	    모바일 이벤트 처리에서 종종 사용!)













	