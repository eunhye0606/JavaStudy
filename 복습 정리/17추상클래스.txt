Test117.java
-클래스 고급
-추상 클래스 (Abstract)
○ 추상 클래스 (abstract)는
   
   선언만 있고 정의가 없는 하나 이상의 메소드(추상 메소드)를 갖는 클래스로
   하위 클래스에서 오버라이딩(Overriding)할 것으로 예상되는 메소드에 대해
   메모리 낭비 없이 미리 호출 계획을 세워두기 위해 만든다.

○ 형식 및 구조
   
   [접근제어지시자] abstract class 클래스명
   {
	   [접근제어지시자] abstract 자료형 메소드명([매개변수],...);
   }

○ 특징
   
   클래스가 적어도 하나 이상의 추상 메소드를 포함할 때
   그 클래스는 클래스 앞에 『abstract』 키워드를 붙여
   추상 클래스로 명시해야 하며
   추상 클래스로 선언한 경우에는
   불완전한 형태의 클래스이므로 객체를 생성할 수 없다.
   추상 메소드가 존재하지 않는 추상 클래스마저도
   객체를 생성할 수 없는 것이다.

   즉, 추상 클래스는 독립적으로 존재할 수 없기 때문에
   상속을 위해서만 존재하며
   추상 클래스에서 상속받은 하위 클래스에서는
   반드시 추상 메소드를 오버라이딩(Overriding) 해야 한다.
   → 오버라이딩 안하면 자식 클래스는 추상이고 클래스로써의 가치없음.

※ 『abstract』 키워드는
   클래스와 메소드에서만 사용할 수 있으며
   멤버 변수나 로컬 변수에서는 사용이 불가능하다.

   추상 클래스안에 클래스메소드나 인스턴스 메소드 정의는 가능하다.
   단, 인스턴스 생성은 안된다.

- protected는 접근제어지시자로서 상속받은 자식클래스에서 사용가능하기도
  하지만 사실은 같은 패키지라 가능한 것두 이따~!

- 추상 메소드(선언만 되어있음!!)

- //『final』 → 키워드로 인해
  // 이 클래스(SortInt117)를 상속받는 클래스에서
  // 이 메소드를 재정의(Method Overriding) 할 수 없다.

//SortInt117 ( 추상 클래스 ) 를 상속 받은 클래스 → 일단은 추상 클래스
// → 추상 메소드 (abstract)를 재정의 (Method Overriding) 하면 
//     클래스의 역할 가능하다.

→// 클래스(설계도)에서 오버라이딩해서 쓸만하게 해뒀으니
		// 클래스 역할 가능. 인스턴스 생성 가능

============================================================================
Test118.java
-상속 관계에 있는 클래스들 간의 캐스팅
- 업 캐스팅, 다운 캐스팅

상위 클래스 SuperTest118
하위 클래스 SubTest118

SUuperTest118 ob2; 
 → 놀라운 사실 이건 생성자가 없으니 가능합니다 에러 안떠요!!
 → SuperTest118타입으로 ob2이름의 변수를
    참조변수 형태로 쓸거라고 선언!!

cf) 참조변수
cf) 객체 생성자 (); 이때부터 메모리할당가능.

SubTest118 ob1 = new SubTest118();

SuperTest118 ob2 = ob1;
== 위아래같음! 자동형변환임. 작은걸(서브) 큰 그릇(슈퍼)에 담는다.
SuperTest118 ob2 = (SuperTest118)ob1;


확인 point
1. Overriding된 메소드는 덮어쓰기가 된거라
   다시 못돌아가!
   메소드랑 변수는 다름!!
   업캐스팅 되면 재정의한 이상 원래의 기능으로 못돌아가!!

2. 변수는 객체별로 따로 할당이 됩니다!
   그래서 클래스명.변수명 → 그 클래스의 변수가 출력
   메모리는 따로! 접근방식에 따라 변수에 따로 접근가능합니다
   → 값타입이니까

3. ob2.c 
   직접 클래스에 접근.
   c는 하위 클래스의 멤버 변수임으로 부모클래스에서는 안보여용

   대신 하위 클래스에서는 상위클래스 멤버변수가 보이지(상속받을 수 있는거면)

4.((SubTest118)ob2).print()
  → 부모에게 print()메소드 없어요
     다운캐스팅해서 하위 객체로 내려와서 print출력해요


상위 객체를 생성했을 때는
다운 캐스팅이 불가능하다.
슈퍼클래스를 통해서 자식클래스에 접근할 수 없다.   
하위 = 상위; //에러 발생.
하위 = (하위)상위; //다운 캐스팅. 런타임에러.


====가능====
1. 하위 객체 생성;	//-- check~!!!!!
2. 상위 = 하위;	// 업 캐스팅. 정상
3. 하위 = 상위; // 에러 발생. 자동형변환 문제 그래서 ↓
4. 하위 = (하위)상위; → 명시적	// 다운 캐스팅.정상
========================================================================
//※ 추가관찰 ----------------------------
		//    다운 캐스팅 가능 여부

		SuperTest118 ob3 = new SuperTest118();
		SubTest118 ob4;

		//System.out.println(((SubTest118)ob3).c);
		//이거도 불가능 왜냐하면 SuperTest118할때
		//SubTest118에 접근 불가
		//
		//System.out.println(ob3.c);
		//--== 부모한테 c가 안보여요 컴파일에러!
		//-- 상위 객체는 하위 객체의 멤버에 접근하는 것이 불가능하다.

		//ob4 = ob3;
		//--==>>에러 발생(컴파일 에러)
		// -- 상위 객체는 하위 객체에 담을 수 (참조할 수 ) 없다.
		//ob4 = (SubTest118)ob3;
		//ClassCastException: 런타임에러!
		//클래스를 캐스팅하는 과정에서 문제가 발생했습니다.
		// -- 작성된 구문의 문법적인 구조만 봤을 때
		//    다운 캐스팅이 이루어진 상황이다.
		//    하지만, 정상적인 캐스팅이 이루어지지 않는다.

		// 현재 SubTest118 객체에 대해 메모리 할당이 이루어지지 않은 상태이기 때문에
		// 인스턴스 생성, 메모리 할당을 하면 되는 것인가?ㄴㄴ
		// -- 그래도 안돼. 그렇게 따지면
		//    하위클래스에 대한 객체 생성을 하긴했는데
		//    메모리 할당이 아니라 슈퍼클래스를 통해 자식클래스에 접근할 수 
		//    있냐 없냐가 문제.
		// 다운 캐스팅은 불가능한 것이다.
========================================================================
○ 업 캐스팅, 다운 캐스팅 정상적으로 이루어지는 경우 ------------------------
   
	1. 하위 객체 생성;	//-- check~!!!!!
	2. 상위 = 하위;	// 업 캐스팅. 정상
	3. 하위 = 상위; // 에러 발생.
	4. 하위 = (하위)상위; → 명시적	// 다운 캐스팅.정상


○ 업 캐스팅, 다운 캐스팅 정상적으로 이루어지는 않는 경우 ------------------------
   
   1. 상위 객체 생성; //-- check~!!!!!
   2. 하위 = 상위; //에러 발생.
   3. 하위 = (하위)상위; //다운 캐스팅. 런타임에러.

※ 업 캐스팅은 항상 가능. 
   다운 캐스팅은 경우(1번)에 따라 가능.

class 학생 
{
}

class 호석
{
}

학생 ob = new 학생();
호석 ob1 = new 호석();

학생 ob = new 호석();
-------   -----------
상        하
가능.

============================================================================