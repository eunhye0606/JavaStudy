Test004.java
-변수와 자료형
-자료형 변수명; //-- 변수 선언
-변수명 = 값; //-- 초기화
-자료형 변수명 = 값 //-- 변수 선언 및 초기화 한번에
-자바에서는 '='대입연산자가 나오면 오른쪽 부터 처리를 해라!
-컴파일 에러 : javac.exe가 찾는다.
-런타임 에러 : 개발자의 의도와 다른 형태로 사용자가 사용할 때 나는 에러.
-알파테스트(개발자), 베타테스트(개발자가 아닌사람들의 테스트)
-클로즈테스트(특정 사용자가 대상), 오픈테스트(아무나),
-덧셈 연산자(+)는 피연산자 중 어느 하나라도 문자열 형태이면 ""
 산술연산자로써의 기능을 하지 않는다. 문자열 결합 연산자로 기능한다
 →처리 결과는 문자열 형태로 반환한다.
 뺄셈 연산자는 그런 기능이 없다!

Test005.java
-변수와 자료형
-변수 선언 → 메모리 공간 확보 / 할당
 자바야 자바야 나 int형 4byte로 변수 선언할거니까 자리예약좀 !!
- 연산 및 처리 → 확보한 메모리 공간에 데이터 담아내기
- '=' 대입 연산도 연산이다! 대입 연산자!!
-자동형변환, 명시적형변환

Test006.java
-변수와 자료형
-키워드 및 식별자
-스코프 영역 안에서 변수명은 식별자이다!!
 식별자 : 구분하기 위한
-문법적으로 변수명을 한글로는 가능하지만 실무에서 사용하지는 않는다!



Test008.java
-형 변환
-접미사활용
 1바이트 2바이트 4바이트  8바이트   4바이트(실수)  8바이트(실수)
-byte   < short   < int    < long   < float       < double
          char  
         2바이트
-boolean
  1바이트

//자료형의 종류와 구분
자료형		데이터		메모리 크기		표현 가능 범위
boolean		참과 거짓	1바이트			T,F

char		문자		2바이트			모든 유니코드 문자

byte		정수		1바이트			-128~ 127
short		정수		2바이트			-32768~ 32767
int		정수		4바이트			+- 21억
long		정수		8바이트			매우 큰 정수


float		실수		4바이트			매우 큰 실수
double		실수		8바이트			더 큰 실수




//자료형 변환

byte → short  ↘ 
		  int →long →float →double
        char   ↗

-자동형변환 : 큰거에 작은거는 자동으로 담긴다 (short가 long에 담긴다)
-명시적형변환(강제형변환), 자동형변환 위배가 아니더라도 
 어디서 형변환 된지 알려줄라고 쓸 때도 있삼!
int a;
char c;
a = c; → int형(4바이트 정수)에 char(2바이트 문자형) → 담긴다 → 자동형변환
c = a; → char(2바이트 문자형)에 int(4바이트 정수형) → 담기지 않음 → 자동형변환 위배
          작은그릇에 큰거 담을 수 없음
          c = (char)a; 
          a의 크기가 2바이트에 담길 크기면 명시적형변환으로 가능
long d = 10000000000;	//백억임
'=' 대입 연산자를 기준으로 우측의 상수 표현이
    int형 메모리에 해당 상수를 할당할 수 없다. 그래서 long으로 자료형 선언
    21억을 넘는다. 그래서 접미사 L을 뒤에 붙혀야 한다...

long d = 10000000000L; O
long d = 10000000000; X
int d = 10000000000; X
int d = 10000000000L; X

int e = 030;
System.out.println("e의 결과:" + e);
		//-->e의 결과:24
접두어 0 → 8진수로 바꿔줌.
030 →64, 8, 1 
8 x 3 = 24이기 때문에 24가됨.

Test009.java
-변수와 자료형 실습 및 테스트 : boolenan

Test010.java
-변수와 자료형 실습 및 테스트 : char
- '' 는 문자형 "" 은 문자열형
- char ch2 = '\n' → \n도 하나의 문자입니다~!

Test022.java
-실수형 데이터타입의 정밀도 테스트 실습
float보다 double이 정밀도가 높다. 십만번 반복했을때 값이 미세하게 다름으로 증명
→ 고로 실수는 double써라~