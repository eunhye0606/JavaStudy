자바 기본 프로그래밍
Test001.java
-클래스 첫 이름은 대문자로 시작.
-mian()함수는 자바 인터프리터가 처음 찾는 함수
-메소드() : 호출하다.
-자바에서 함수(메소드)는 독립적으로 존재할 수 없다.
-→ 클래스에 정의되는 형태로 함수를 만든다.
-그래서 다른 학문(수학 등)에서 말하는 함수와 차이가 있다.
-→ 그래서 자바에서의 함수는 메소드라고 부른다.
-함수,메소드 → 기능,동작,행위
-메소드는 정의되어야 호출(println())으로 호출할 수 있다.

Test002.java
-컴파일 실행 실습

자바의 개요 및 특징
Test003.java
-println()메소드는 마지막에 라인 스킵(개행)을 한다.
-print()는 하지않는다.

자바 기본 프로그래밍
Test004.java
-변수와 자료형
-자료형 변수명; //-- 변수 선언
-변수명 = 값; //-- 초기화
-자료형 변수명 = 값 //-- 변수 선언 및 초기화 한번에
-자바에서는 '='대입연산자가 나오면 오른쪽 부터 처리를 해라!
-컴파일 에러 : javac.exe가 찾는다.
-런타임 에러 : 개발자의 의도와 다른 형태로 사용자가 사용할 때 나는 에러.
-알파테스트(개발자), 베타테스트(개발자가 아닌사람들의 테스트)
-클로즈테스트(특정 사용자가 대상), 오픈테스트(아무나),
-덧셈 연산자(+)는 피연산자 중 어느 하나라도 문자열 형태이면 ""
 산술연산자로써의 기능을 하지 않는다. 문자열 결합 연산자로 기능한다
 →처리 결과는 문자열 형태로 반환한다.
 뺄셈 연산자는 그런 기능이 없다!

Test005.java
-변수와 자료형
-변수 선언 → 메모리 공간 확보 / 할당
 자바야 자바야 나 int형 4byte로 변수 선언할거니까 자리예약좀 !!
- 연산 및 처리 → 확보한 메모리 공간에 데이터 담아내기
- '=' 대입 연산도 연산이다! 대입 연산자!!
-자동형변환, 명시적형변환

Test006.java
-변수와 자료형
-키워드 및 식별자
-스코프 영역 안에서 변수명은 식별자이다!!
 식별자 : 구분하기 위한
-문법적으로 변수명을 한글로는 가능하지만 실무에서 사용하지는 않는다!

Test007.java
-print() / println() / printf() / format()
-printf(), format()은 JDK 1.5부터 지원되는 메소드
-두 개 사용법은 같다.
-format()은 String에서 자주 쓴다.
-System.out.printf("○ + ○ + ○", 10, 20, 30);
-System.out.format("○ + ○ + ○", 10, 20, 30);
-서식 출력용 메소드
-출력하기 위해 틀짜놓고 하는것.
-메소드 뒤에 ln이 없기에 print()메소드 처럼 개행이 안된다.
-그래서 \n 혹은 %n으로 개행출력.
-%d == 10진수 정수형 ( 1, 10, 94 .. )
-%f == 실수(3.14 ...)
-%.2f : 소수점 이하 두 번째 자리까지 표현
        반올림함.
-%d로 틀짜고 실수를 넣으면 런타임에러가 발생한다 (컴파일에러는 문법을 봄)
-문법은 맞는데 개발자가 정수를 목적으로 코드 짰는데
 사용자가 실수를 넣어서 런타임 에러 발생.

Test008.java
-형 변환
-접미사활용
 1바이트 2바이트 4바이트  8바이트   4바이트(실수)  8바이트(실수)
-byte   < short   < int    < long   < float       < double
          char  
         2바이트
-boolean
  1바이트

//자료형의 종류와 구분
자료형		데이터		메모리 크기		표현 가능 범위
boolean		참과 거짓	1바이트			T,F

char		문자		2바이트			모든 유니코드 문자

byte		정수		1바이트			-128~ 127
short		정수		2바이트			-32768~ 32767
int		정수		4바이트			+- 21억
long		정수		8바이트			매우 큰 정수


float		실수		4바이트			매우 큰 실수
double		실수		8바이트			더 큰 실수




//자료형 변환

byte → short  ↘ 
		  int →long →float →double
        char   ↗

-자동형변환 : 큰거에 작은거는 자동으로 담긴다 (short가 long에 담긴다)
-명시적형변환(강제형변환), 자동형변환 위배가 아니더라도 
 어디서 형변환 된지 알려줄라고 쓸 때도 있삼!
int a;
char c;
a = c; → int형(4바이트 정수)에 char(2바이트 문자형) → 담긴다 → 자동형변환
c = a; → char(2바이트 문자형)에 int(4바이트 정수형) → 담기지 않음 → 자동형변환 위배
          작은그릇에 큰거 담을 수 없음
          c = (char)a; 
          a의 크기가 2바이트에 담길 크기면 명시적형변환으로 가능
long d = 10000000000;	//백억임
'=' 대입 연산자를 기준으로 우측의 상수 표현이
    int형 메모리에 해당 상수를 할당할 수 없다. 그래서 long으로 자료형 선언
    21억을 넘는다. 그래서 접미사 L을 뒤에 붙혀야 한다...

long d = 10000000000L; O
long d = 10000000000; X
int d = 10000000000; X
int d = 10000000000L; X

int e = 030;
System.out.println("e의 결과:" + e);
		//-->e의 결과:24
접두어 0 → 8진수로 바꿔줌.
030 →64, 8, 1 
8 x 3 = 24이기 때문에 24가됨.

Test009.java
-변수와 자료형 실습 및 테스트 : boolenan

Test010.java
-변수와 자료형 실습 및 테스트 : char
- '' 는 문자형 "" 은 문자열형
- char ch2 = '\n' → \n도 하나의 문자입니다~!

Test011.java
//나눗셈 연산 실습
- 정수와 정수의 나눈셈 ( 몫 반환 ) 
- 피 연산자로 실수가 포함되어 있는 나눗셈
  실수 기반의 연산 수행.
Like 덧셈 연산자는 피연산자가 문자열or 문자가 있으면 문자열 결합 연산자로 수행.



Test012.java
-원의 넓이와 둘레를 구하는 프로그램 구현
- final → 변수의 상수화하는 키워드
- 변수는 수시로 변할 수 있다.
  상수는 변하지 않는다 이름 없는 특징
- final 변수는 대문자로 쓰는 암묵적 룰!
- 언더바스코어 표기법 

Test013.java
-직사각형의 넓이와 둘레를 구하는 프로그램 구현

Test014.java
-자바의 기본 입출력 : BufferedReader 클래스
-버퍼 : 임시기억공간, Like 키보드같은 장치
-throws IOException : 오류나면 그 오류 메소드 밖으로 던질게 자바

BufferedReader br = new BufferedReader(new InputStreamReaer(System.in)); 
                                                           -----------
                                                           바이트 입력값
                                       ---------------------------------
                                       바이트 → 문자 번역기
---------------------------------------
        문자 입력을 읽어들이는 장치
br.readLine(); → BufferedReader의 readLine() → 문자열 반환!
Integer.parseInt() → 매개변수로 넘겨받은 문자열 데이터 → 정수형으로 변환
단, 이 때 넘겨받은 문자열 데이터는 숫자모양이여야 한다. (NuberFormat)

      
Test015.java
-삼각형의 밑변의 길이와 높이를 사용자로부터 입력받아
 삼각형의 넓이를 구하는 프로그램 구현

area = (double)length * height /2; //하나만 실수로 바꿔.
	//area = (double)length * height /2.0; //이게 깐지
-실수 기반의 연산을 수행해야해서 
 나눗셈 연산 : 피연산자 중 하나라도 실수면 실수기반 연산 수행!

Test016.java
-사용자로부터 이름, 국어점수, 영어점수, 수학점수를 입력받아
- 이름과 총점을 출력하는 프로그램을 구현한다.

Test017.java
- 자바의 기본 입출력 : System.int.read()
  BufferedReader의 readLine()과 비교!

System.in.read() 메소드는 한 문자만 가져온다.
readLine() 처럼 문자열대기열에 있는거 가져오는 건 같음.
단 , 입력받은 하나의 문자를 문자 그대로 가져오는 것이 아니라
ASCII Code 값으로 반환한다.
즉, 'A'를 입력하면 65로 가져온다! int형으로 변환해서 가져옴!!

-System.in.skip(매개변수);
 매개변수만큼 안읽고 건너 뛴다.
 엔터 == \r + \n

Test018.java
-printf() , format() 
-양수 강조법 : %+d
               %-d → 런타임에러 발생.
-음수 강조법 : -%d
- //System.out.printf("%d\n",'A');
		//처리가 아니라 표현이니까 아스키문자 - int 아니야
- 'A'는 char형이라 %c 해야함.
- 저렇게 쓰면 런타임 에러뜸!!
-%c 문자형, %s는 문자열형

//HEX 16진수로 바꿔서
//DEC 10진수
//OCT 8진수
//BIN 2진수
System.out.printf("%h\n", 365);
                    d
                    0
                    b
System.out.printf("%8.2f\n", 123.236);
		//  123.24
		//dot도 자리 하나
		// 앞에 두 자리
-    -    -    -    -    -    -    -
          1    2    3    .    2    4
		System.out.printf("%2.2f\n",123.236);
		//123.24 
		//쟤가 준 자리수가 우리자루에 비해 적으면
		//걍 무시깜

		System.out.printf("%3d\n",1231313);
		//1231313
		//int도 마찬가지

Test019.java
-자바의 기본 입출력 : java.util.Scaaner
※ java.util.Scanner
	 단락 문자 패턴을 사용하여 입력을 토큰에 따라 분할하며
   디폴트(default)로 사용되는 단락문자는 공백이다.
   작성된 다음 토큰은 『next()』 메소드를 사용
   다른 형태(자료형)의 값으로 변환할 수 있다.
- Scanner는 BufferedReader의 통역기(InputStreaReader)가 없어도 됨!
- IOException 없어도 됩니다. 인증받은 새끼임.

-sc.next()는 br.readLine()과 같은놈.
단, Integer.parseInt같은거 하지마.
    nextInt()가 있지롱
    별도의 형변환과정이 필요없습니다.

Test020.java
-import 안하고
- 매번 java.util.Scanner sc = new java.util.Scanner(System.in);
  가능하긴한데 할거임? 개귀찮음.

-scanner 공백 구분이 defalt임.
- 스페이스 무한해도 공백 한개로 인지
- 엔터도 공백으로 인지
- 입력값이 부족하면 당연히 안넘어가고 
- 많으면 뒤로 무시함.

Test021.java
// System.out.println("\"); -->컴파일에러
   애초에 저게 안됨. 뒤에 닫는 " 이거 써도 앵 \다음머임??
   하면서 계~속 문자열로 생각.
// 왜냐면 자바는 \이거 보고 아 ~ \s ? \d? 이러고 있음.
// 그래서 \이거 문자로 쓰고 싶으면 \\두개~
sc = new Scanner(sc.next()).useDelimiter("\\s*,\\s*");
이제 배우니까 알겠다.
sc를 초기화함. sc덮어쓰기함. 
sc = new Scanner(sc.next()).useDelimiter("\\s*,\\s*");
                            -------------
                             사용 구분자
                                         ------------
                                         모든문자열,모든문자열

→ 즉, 문자열을 콤마로 구분할게!

Test022.java
-실수형 데이터타입의 정밀도 테스트 실습
float보다 double이 정밀도가 높다. 십만번 반복했을때 값이 미세하게 다름으로 증명
→ 고로 실수는 double써라~

Test023.java
-산술 연산자
- 사용자로부터 임의의 정수를 두 번입력받아(한자리 아니여도됨)
- 사칙연산 및 나머지 연산을 수행하여 
- 그 결과를 출력하는 프로그램을 구현.
  
  문자열안에서 %를 표현하려면 "%%" 두번 쓰면 된다~!

Test024.java
- 비트 단위 연산자
  초급 개발자와 고급개발자의 차이는 비트연산자이다~
- 비트낫 == 1의 보수, 비트열반전
- 음수는 바로 2진수 계산 할 수 없다.
- 그래서 더해서 0이 되는 10진수 → 2진수로 바꾼 뒤 
   → 1의 보수를 취한뒤 + 1 을 한 값이 음수의 2진수이다.

Test025.java
- 비트and, 비트or,         비트xor
  둘다 t   둘중하나라도 t  둘이 다르면 t

Test026.java
// 비트 단위 연산자 『xor』 연산자를 활용하여
// 두 변수에 담겨잇는 내용(값) 바꾸기
x = x^y;
y = y^x;
x = x^y;

Test027.java
- shift !!! 존나 어려움.
<< 3: ← 이쪽으로 3움직여라. 뒤에는 0으로 채움
>>>3: → 이쪽으로 3움직여라. 앞에는 0으로 채움
>> 3: → 이쪽으로 3움직여라. 단, 앞에는 1로 채움 :  이거 부호변하는거방지!

Test028.java
- 논리연산자
논리and, 논리or, ! →  둘다 참, 둘 중하나 참!, 논리부정
cf ) ~ : 이건 비트부정~ 비트낫~ 1의보수 ~ 비트열반전~

Test029.java
-삼항 연산자 == 조건 연산자
 피연산자 연산자 피연산자 연산자 피연산자
 -------         --------        --------
   1항              2항             3항

  피연산자 ? 피연산자 : 피연산자
  -------    --------   --------
    1항        2항         3항

 1항의 연산 결과 → true  → 2항 수행
 		 → false → 3항 수행

Test030.java
- 사용자로부터 임의의 정수를 입력받아
  입력받은 정수가 양수인지, 음수인지, 0인지 구분하는
  프로그램 구현

Test031.java
-실행 흐름의 컨트롤(제어문)
-if ~ else
//사용자로부터 임의의 문자를 하나 입력받아
//대문자이면 소문자로 소문자이면 대문자로
//알파벳이 아닌 기타문자이면 입력오류 처리하는 프로그램을 구현

-boolean은 자동형변환 대상이 아닙니다. 
 그래서 명시적형변환도 안됩니다!

Test032.java
-사용자로부터 임의의 연도를 입력받아
 윤년인지 평년인지 판별하여
 결과를 출력하는 프로그램을 구현하라.

- 윤년 조건
  4의 배수이고 100의 배수가 아니다
  혹은 400의 배수이면 윤년이다.

Test033.java
//1. 프로그램을 작성할 때 주어진 조건에 따라
//   분기 방향을 정하기 위해 사용하는 제어문에는
//   if문, if~else문, 조건연산자, 복합if문(if문 중첩),
//   switch 문이 있다.

//2. if문은 if 다음의 조건이 참일 경우,
//   특정 문장을 수행하고자 할 때 사용되는 구문이다.

Test034.java
-if ~ else 실습

Test035.java
-if ~ else 실습, 홀수,짝수,0
-else에서 result를 출력할 때, 초기화를 하지않으면
 자바는 영짝홀 아닐 때, result가 뭔데~ 해서 컴파일에러발생!
// ※ if ~ else 구문의 중첩 구문은
//	  반드시 else로 끝나야 하는 것이 아니다.
//	  다만, 출력해야 할 구문을 처리하는 과정에서
//	  문제가 발생하지 않는 구문으로 작성해야 한다.


// ※ 조건문 구성 과정에서 이외의 영역(else)을
//    업무에 포함된 내용으로 처리하는 것은 바람직하지 않을 경우가 있다.
//    불가능한 경우는 어쩔 수 없더라도
//    가급적이면 업무에 포함되지 않는 내용을
//    이외의 영역(else)에서 처리할 수 있도록 하자.
// ex)주민번호, 010 등

Test036.java
-if ~ else 실습
// 사용자로부터 임의의 정수를 입력받아
// 다음과 같은 판별 결과를 출력하는 프로그램을 구현한다.

// 2의 배수 / 3의 배수 / 2와 3의 배수 / 2와 3의 배수 아님

Test037.java	과제
-if ~ else 실습
//사용자로부터 임의의 연도를 입력받아
//입력받은 연도가... 윤년인지 평년인지 판별하여
//그 결과를 출력하는 프로그램을 구현한다.
//단, 입력은 BufferedReader의 readLine()을 활용하고
//if 조건문을 활용하여 연산을 수행할 수 있도록 한다.

Test038.java
//사용자로부터 임의의 두 정수와 연산자를 입력받아
// 해당 연산자의 연산 처리 결과를 출력하는 프로그램을 구현해라.
// 단, if 조건문을 활용하여 처리할 수 있도록 하며,
// 연산 결과는 편의상 정수 기반으로 처리될 수 있도록 한다.

// 실행 예 )
// 첫 번째 정수 입력 : 
// 두 번째 정수 입력 : 
// 연산자 입력 [+ - * /] :

Test039.java
// 사용자로부터 임의의 정수 세개를 입력받아
// 작은 수에서 큰 수 순으로 출력하는 프로그램을 구현한다.

// 실행 예)
// 첫 번째 정수 입력 : 7
// 두 번째 정수 입력 : 70
// 세 번째 정수 입력 : 42

// >> 정렬 결과 : 7 42 70
// 계속하려면 아무 키나 누르세요 .....
// (1) 첫 번째 vs 두 번째
//		→ 첫 번째 정수 > 두 번째 정수보다 클 경우 자리 바꿈.
// (2) 첫 번째 vs 세 번째
//		→ 첫 번째 정수 > 세 번째 정수보다 클 경우 자리 바꿈
// (3) 두 번째 vs 세 번째
//		→ 두 번째 정수 > 세 번째 정수보다 클 경우 자리 바꿈.

- 나중에 쓴건데 max라는 변수에 담아서 실행하는 법도 있다.

Test040.java
// 사용자로부터 임의의 정수 5개를 입력받아
// 짝수별, 홀수별 합계를 출력하는 프로그램을 구현한다.
// 단, Scanner를 활용하여 데이터를 입력받을 수 있도록 한다.

// 실행 예 )
// 임의의 정수 5개 입력 : 1 2 3 4 5

// >> 짝수의 합은 6이고, 홀수의 합은 9 입니다.
// 계속하려면 아무 키나....

-누적합은 초기화 0부터
-누적곱은 초기화 1부터!

Test041.java	과제
-if ~ else 실습
//if ~else 

//  사용자로부터 임의의 알파벳 한 문자를 입력받아
//  이를 판별하여 입력받은 알파벳이 모음일 경우만
//  결과를 출력하는 프로그램을 구현한다.
//  단, 대소문자를 모두 적용할 수 있도록 처리한다.
//  또한, 알파벳 이외의 문자가 입력되었을 경우
// 입력 오류에 대한 내용을 사용자에게 안내해 줄 수 있도록 한다.

// 실행 예 )
// 임의의 알파벳 한 문자 입력 : A
// >> 모음 OK ~!!!
// 계속하려면 아무 키나...

// 임의의 알파벳 한 문자 입력 : e
// >> 모음 OK ~!!!
// 계속하려면 아무 키나...

// 임의의 알파벳 한 문자 입력 : B
// 계속하려면 아무 키나...

// 임의의 알파벳 한 문자 입력 : 1
// >> 입력 오류 ~!!!
// 계속하려면 아무 키나...

Test042.java	과제
//사용자로부터 임의의 문자를 하나 입력받아
//대문자이면 소문자로 소문자이면 대문자로
//알파벳이 아닌 기타문자이면 입력오류 처리하는 프로그램을 구현한다.


// 실행 예)
// 한 문자 입력 : A
// A → a
//계속하려면 아무 키나 누르세요....


// 한 문자 입력 : b
// b → B
//계속하려면 아무 키나 누르세요....

// 한 문자 입력 : 7
// >> 입력 오류 ~!!!
//계속하려면 아무 키나 누르세요....

Test043.java
-switch 실습
// switch 문 실습

/*
○ 다중 선택문이라 하며. switch 문 다음의 수식 값에
   따라 실행 순서를 여러 방향으로 분기할 때 사용하는
   문장이다.

○ 형식 및 구조
   switch(수식)
   {
	   case 상수1 : 문장1; [break;]		break 멈추고 (빠져나간다.)
	   									continue (뒷부분 무시하고) 계속해라
	   case 상수2 : 문장2; [break;]
	       :              :
	   [default : 문장n+1; [break;]]		//[]는 생략가능!
	}										//if문에 else랑 비슷
											//반드시 디폴트 ㄴㄴ
											//처리영역에서는 가능
											// 출력에서 에러날수는 있음.

	switch 문의 『수식』과 case의 『상수』는
	byte, short, int, long 형이어야 한다.
	//정수형태의 프리미티브형식만

	case 문 뒤에 『break;』가 없는 형태인 경우
	다음 case 문의 문장을 계속해서(이어서) 수행하게 된다. → (기본모델)
	『break;』가 존재할 경우
	해당 지점에서 수행을 멈춘 후 switch 문을 빠져나간다. → (일반모델)

Test044.java
-switch 실습
// 사용자로부터 1부터 3까지의 정수 중 하나를 입력받아
// 입력받은 정수만큼의 별문자(★)가 출력되는 프로그램을 작성한다.
// 단, 두 가지 방법으로 구현할 수 있도록 한다.

//① switch 문의 일반 모델을 사용한다.
//② switch 문의 기본 모델을 사용하되,
//   『break』를 딱 한 번만 사용할 수 있도록 구성한다.

// 실행 예)
// 임의의 정수 입력(1~3) : 3
// ★★★
// 계속하려면 아무 키나...

// 임의의 정수 입력(1~3) : 1
// ★ 
// 계속하려면 아무 키나...

// 임의의 정수 입력(1~3) : 7
// 입력 오류 ~ !!
// 계속하려면 아무 키나...

-누적을 이용하자!

Test045.java
// 사용자로부터 임의의 두 정수와 연산자를 입력받아
// 해당 연산자의 처리 결과를 출력하는 프로그램을 구현하라.
// 단, switch 문을 활용하여 처리할 수 있도록 하며
// 연산 결과는 편의상 정수 형태로 처리할 수 있도록 한다.

// 실행 예)
// 첫 번째 정수 입력 : 3
// 두 번째 정수 입력 : 17
// 연산자 입력 [+ - * /] : -

// >> 3 - 17 = -14
// 계속 ..............

Test046.java
- 반복문 실습
○ 반복문의 개요
	
	주어진 조건이 『참』인 경우
	일정한 영역의 문장을 반복 수행하다가
	조건식이 거짓이 되는 순간이 오면,
	반복 수행을 중단하는 문장이다.
	이러한 반복문에는 『while』, 『do ~ while』,『for』문 등이 있으며
	반복문의 제어를 위해 『break』,『continue』문을
	사용하는 경우가 있다.

○ while 문

	조건식을 먼저 비교하여
	조건식의 처리 결과가 참인 경우, 특정 영역을 반복 수행하는 문장으로
	반복 횟수가 정해져 있지 않은 경우나
	반복 횟수가 많은 경우 주로 사용한다.
	while 문은 조건이 맞지 않은 경우
	반복은 커녕 단 한 번도 실행되지 않을 수 있다.

○ while 문의 형식 및 구조

	while(조건식)
	{
		실행문;
	}
☆ 문제 1부터 100까지의 합을 계산하여
   결과 출력하는 프로그램을 구현한다.
   단 , while 반복문을 사용한다.

   실행 예 )
   1부터 100까지의 합: 5050
   계속하려면 아무 키나.......

※ 문제 인식 및 분석
	1. 출력 구문이 반복문의 영역 밖에 위치해야 한다.
	2. 1부터 1씩 증가할 변수와 누적합을 담을 변수
	   두 개의 변수가 필요하다.

Test047.java
-반복문(while)실습
//1부터 100까지의 정수 중에서 
//짝수들의 합을 계산하여 결과값을 출력하는 프로그램을 구현하라.
// 단, 조건문을 사용하지 않도록 하며,
// while 반복문을 활용하여 작성할 수 있도록 한다.

// 실행 예)
// 1부터 100까지의 정수 중 짝수의 합 : xxxx
// 계속 .........


//※ 문제 인식 및 분석
// 2+ 4+ 6+ 8 + ... + 100
//	- 초기값 : 2
//	- 증가값 : 2
//  - 한계값 : 100

Test048.java
-반복문(while)실습
//1부터 100까지의 정수 중에서
//짝수들의 합과 홀수들의 합을 따로 구분하여 계산한다.
// 단, 반복문은 while 문을 사용할 수 있도록 하며,
// 조건 구문은 if 조건문을 사용하여 작성할 수 있도록 한다.

// 실행 예 )
// 1부터 100까지의 정수 중
// 짝수의 합 : 2550
// 홀수의 합 : 2550
//계속 ............

Test049.java
-반복문(while)실습
//실행 예 )
// 1 부터 100 까지 정수의 합은 : 5050
// 1 부터 100 까지 짝수의 합은 : 2550
// 1 부터 100 까지 홀수의 합은 : 2500
//계속 ............

Test50.java
-반복문(while)실습
//1부터 100까지 정수의 합을 구하되,
//10의 배수가 될 때 마다... 결과를 출력하는 프로그램을 구현하라.

// 실행 예 )
// 1~10 까지의 합:
// 1~20 까지의 합:
// 1~30 까지의 합:
//	    :	
//1~100까지의 합 : 
//계속 .............

Test051.java
-반복문(while)실습
-n/n+1 + n+1/n+2 + ... + n+8 / n+9 의 연산 처리 결과를 출력하는 프로그램을 구현.

Test052.java
//반복문(while 문) 실습
//1 * 2 * 3 * ...* 9 * 10
-누적곱은 1로 초기화.

Test053.java
-반복문(while)실습
//사용자로부터 임의의 정수를 입력받아
//입력받은 정수가 소수인지 아닌지를 판별하여
//결과를 출력하는 프로그램을 구현한다.
※ 소수 : 1 또는 자기 자신의 값 이외에 어떤 수로도 나누어 떨어지지 않는 수.
//		     단, 1 은 소수 아님.

Test054.java

-반복문(while)실습
// 사용자로부터 임의의 두 정수를 입력받아
// 작은 수부터 큰 수 까지의 합을 구하여
// 결과를 출력하는 프로그램을 구현한다.

// 실행 예)
// 첫 번째 정수 입력 : 10
// 두 번째 정수 입력 : 20 
// >> 10 ~ 20 까지의 합은 : xxxx
// 계속하려면 ........

// 첫 번째 정수 입력 : 10
// 두 번째 정수 입력 : 2 
// >> 2 ~ 10 까지의 합은 : xxxx
// 계속하려면 ........

Test055.java	과제
-반복문(while)실습
//   사용자로부터 임의의 정수를 입력받아
//   1부터 입력받은 그 정수까지의
//   전체 합과, 짝수의 합과 , 홀수의 합을 
//   각각 결과값으로 출력하는 프로그램을 구현한다.


Test056.java
-반복문(while)실습
//사용자로부터 원하는 단(구구단)을 입력받아
//해당하는 구구단을 출력하는 프로그램을 구현한다.
// 단, 1단 ~ 9단 사이의 수를 입력받은 상황이 아니라면
// 이에 대한 안내를 한 후 프로그램을 종료할 수 있도록 처리한다.
//실행 예 )
//원하는 단(구구단) 입력 : 7
//7 * 1 = 7
//7 * 2 = 14
//7 * 3 = 21
//    :
//7 * 9 = 63
//계속하려면 아무 키나 .......

//원하는 단(구구단) 입력 : 11
//1부터 9까지의 정수만 입력이 가능합니다.
//계속하려면 아무 키나 .......
return; → 프로그램 종료, main()함수 종료.


Test057.java
-반복문(do ~ while)실습
○ 개요
	『do ~ while』문은 『while』문과 마찬가지로
	특정한 영역을 반복 수행하는 반복문이다.
	다만 『while』문과 다른 점은
	조건식에 대한 검사를 반복문을 수행한 이후에 한다는 것이다.
	이와 같은 성격으로 인해 반드시 한 번은 수행하게 되는 특징을 갖는다.

○ 형식 및 구조
  
	do 
	{
		실행문;
	}
	while(조건식);

// do ~ while 문의 활용 모델
// 예를 들어... 사용자로부터 특정 범위의 정수가 입력될 때 까지
// 입력받은 행위 자체를 반복해서 수행해야 하는 상황이라 가정한다.

//즉, 최소 한 번은 사용자의 입력값을 받아오는 처리를 수행해야
//반복을 추가로 수행할지 말지의 여부를 결정할 수 있는 상황이다.


Test058.java


-반복문(do ~ while 문) 실습

// 사용자로부터 여러 개의 양의 정수를 입력받고,
// 그 합을 계산하여 출력하는 프로그램을 작성한다.

// 단, -1이 입력되는 순간
// 입력을 중지하고 그동안 입력된 정수의 합을 출력해주는 프로그램을 구현한다.
// 즉, 『-1』을 입력 중지 커맨드로 활용한다.
// do ~ while 문을 활용하여 문제를 해결할 수 있도록 한다.



// 실행 예 )
// 정수1 입력 : 10
// 정수2 입력 : 5
// 정수3 입력 : 8
// 정수4 입력 : 9
// 정수5 입력 : -1

// >> 현재까지 입력된 정수의 합 : xxxx
// 계속하려면 .............

Test059.java
-반복문(do ~ while 문) 실습

○ 개요

    『for』문은 정해진 횟수만큼 반복해야 하는 경우
	유용하게 사용되어지는 반복문으로
	『while』문과 마찬가지로 반복 실행해야 하는 구문이
	조건에 맞지 않을 경우 한 번도 수행하지 않을 수 있으며
	루프 변수의 초기값, 조건식, 증감식 등을 한 지점에서 확인할 수 있기 때문에
	가독성이 높은 반복문에 해당한다.

○ 형식 및 구조
	
	for (수식1; 수식2; 수식3)
	{
		실행문;
	}

	수식1은 루프 변수의 초기화를 위해 사용되며,
		    최초 단 한번만 실행된다.
	수식2는 조건식을 나타내는 것으로 이 조건식(수식2)이 만족하면
	        루프를 반복해서 수행하게 된다.
			『for』문의 진행 순서는 수식2가 참이면 반복문을 수행하고
			수식3을 실행한 후 수식2의 조건식을 다시 검사하는 구조로 진행된다.
			따라서 처음에 조건식의 처리 결과가 거짓일 경우
			『for』루프를 한 번도 수행하지 않게 되는 것이다.
	수식3은 루프 변수의 재초기화를 위해 사용되어지며,
		    반복문의 조건식을 무너뜨리게 되는 증감식으로 처리하는 것이 일반적이다.
			컴마(『,』를 이용하여 여러 문장을 동시에 수행할 수도 있다.

수식2를 제외하고는 콤마가 사용가능하다!


Test060.java

-반복문(for 문) 실습


//1부터 100까지의 정수 중에서
//4의 배수만 출력하는 프로그램을 구현한다.
//단 for문을 활용해야 하며
//한 줄에 5개씩만 출력할 수 있도록 한다.


//실행 예 )
// 4	8	12	16	20
//24	28	32	36	40
//			:
//			:
//계속하려면 아무 키나 누르세요.....



Test061.java
-반복문(for 문) 실습

//다중 for문(반복문의 중첩)을 활용한 구구단 출력 실습

//실행 예)
/*
[2단]
2 * 1 = 2
2 * 2 =4
	:
2 * 9 = 18

[3단]
  :
9 * 9 = 81
// 계속하려면..........
*/

Test062.java
-반복문(for 문) 실습
//다중 for문(반복문의 중첩)을 활용한 구구단 출력 실습

//① 2중첩 *2		//②3중첩 *1


// 실행 예)
/*

2 * 1 = 2               3 * 1 = 3               4 * 1 = 4               5 * 1 = 5
2 * 2 = 4               3 * 2 = 6               4 * 2 = 8               5 * 2 = 10
2 * 3 = 6               3 * 3 = 9               4 * 3 = 12              5 * 3 = 15
2 * 4 = 8               3 * 4 = 12              4 * 4 = 16              5 * 4 = 20
2 * 5 = 10              3 * 5 = 15              4 * 5 = 20              5 * 5 = 25				→→→ 1문단
2 * 6 = 12              3 * 6 = 18              4 * 6 = 24              5 * 6 = 30
2 * 7 = 14              3 * 7 = 21              4 * 7 = 28              5 * 7 = 35
2 * 8 = 16              3 * 8 = 24              4 * 8 = 32              5 * 8 = 40
2 * 9 = 18              3 * 9 = 27              4 * 9 = 36              5 * 9 = 45

6 * 1 = 6               7 * 1 = 7               8 * 1 = 8               9 * 1 = 9
6 * 2 = 12              7 * 2 = 14              8 * 2 = 16              9 * 2 = 18
6 * 3 = 18              7 * 3 = 21              8 * 3 = 24              9 * 3 = 27
6 * 4 = 24              7 * 4 = 28              8 * 4 = 32              9 * 4 = 36
6 * 5 = 30              7 * 5 = 35              8 * 5 = 40              9 * 5 = 45				→→→ 2문단
6 * 6 = 36              7 * 6 = 42              8 * 6 = 48              9 * 6 = 54
6 * 7 = 42              7 * 7 = 49              8 * 7 = 56              9 * 7 = 63
6 * 8 = 48              7 * 8 = 56              8 * 8 = 64              9 * 8 = 72
6 * 9 = 54              7 * 9 = 63              8 * 9 = 72              9 * 9 = 81
계속하려면 아무 키나 누르십시오 . . .

//1. Test061과 비교하여
//출력의 방향이 다르기 때문에
//반복문의 제어 흐름도 달라져야 한다.
//콘솔기반의 출력환경이기 때문에..

//2.(1)에따라
//단과 곱해지는 수의 위치가
//달라진 상태에서 반복문 구성

//3.(2)에서 처리한 결과를 
//두 문단으로 반복하는 반복문 구성
//check~!!!! 반복문에 2의 결과를 삽입

//4.같은 구문을 
//두 문단으로 나누어 처리하는 과정에서
//문단에 따라 주어진 환경 (h의 값)을 활용하는 방법으로
//최종 반복문 3중첩.

Test063.java	과제
-반복문(for 문) 실습
//◎ 과제
//   다음과 같은 내용이 출력될 수 있도록
//   반복문의 중첩 구문을 작성하여 프로그램을 구현한다.

/* 실행 예)
    *	→ 공백 4 별 1    
   **   → 공백 3 별 2
  ***   
 ****
*****
*/

Test064.java	과제
-반복문(for 문) 실습
//다중 for문(반복문의 중첩)을 활용한 별찍기 실습

//◎ 과제
//   다음과 같은 내용이 출력될 수 있도록
//   반복문의 중첩 구문을 작성하여 프로그램을 구현한다.

/* 실행 예)  

    *
   ***
  *****
 *******
*********
*/

Test065.java	과제
-반복문(for 문) 실습
//다중 for문(반복문의 중첩)을 활용한 별찍기 실습

//◎ 과제
//   다음과 같은 내용이 출력될 수 있도록
//   반복문의 중첩 구문을 작성하여 프로그램을 구현한다.

/* 실행 예)

*********
 *******
  *****
   ***
    *
*/

Test066.java	과제
-반복문(for 문) 실습
//다중 for문(반복문의 중첩)을 활용한 별찍기 실습

//◎ 과제
//   다음과 같은 내용이 출력될 수 있도록
//   반복문의 중첩 구문을 작성하여 프로그램을 구현한다.

/* 실행 예)

    *   
   ***  
  ***** 
 *******
*********
 *******
  ***** 
   ***  
    *   
*/

Test067.java
-break 실습
// 다음과 같은 처리가 이루어지는 프로그램을 구현한다.
// 단, 입력받는 정수는 1 ~100 범위 안에서만
// 가능하도록 작성한다.

// 실행 예)
// 임의의 정수 입력 : -10

// 임의의 정수 입력 : 0

// 임의의 정수 입력 : 2022

// 임의의 정수 입력 : 10
// >> 1 ~ 10 까지의 합 : 55
// 계속하시겠습니까?(Y/N)? : y

// 임의의 정수 입력 : 100
// >> 1 ~ 100 까지의 합 : 5050
// 계속하시겠습니까?(Y/N) : N
// 계속하려면 아무 키나 누르세요 ... → 프로그램 종료.
br.reaLine()은 문자열을 받아옴! 
System.in.read()는 아스키코드를 받아옴!! 
엔터 = \r + \n입니다.
System.in.skip(2); : 대기열 엔터 스킵!!
※ break
반복문 멈추고 빠져 나가라 ~ 
가장 가까운 반복문을 빠져나간다!!
cf) continue
뒷 부분 무시하고 계속해라~~ 
→ 얘는 반복문의 처음으로 돌아갑니다! 반복문을 끝낼 수가 없어요 ~!!


Test068.java
-continue 실습

//continue 를 활용하여
// 다음과 같이 출력될 수 있도록 프로그램을 구현한다.
// 실행 예)

/*
1 : 1
3 : 4
5 : 9
7 : 16
  :
  :
  :
99: 2500
계속하려면 아무 키나 누르세요....

Test069.java
-return 실습

// ※ return 키워드가 지니는 두 가지 의미
//    ① 『값의 반환.』 return을 포함하고 있는 메소드에서 
//       지점에 값을 두고 온다..
//		  return + 무엇을 → 이런 형식


//    ② 『메소드 종료.』 return을 포함하고 있는 메소드 종료.
//        지금은 main()만 정의 중 → 프로그램 종료.
//        return; 단일.

Test070.java
-지역변수와 전역변수
// 지역 변수의 초기화 테스트

//Test071.java와 비교
// ※ 지역 변수는 초기화 과정을 거치지 않으면 사용할 수 없다.
//    자바가 자동으로 초기화를 수행해 주거나 하지 않는다.

//클래스의 영역에서 선언한 변수 == 전역 변수 == 글로벌변수
	// 클래스 변수 != 전역 변수
	// 클래스 변수 따로 있음
	public static void main(String[] args)
	{
		//메소드의 영역에서 선언한 변수 == 지역 변수 == 로컬변수
		int n;
		// --선언 후 초기화 과정을 거치지 않은 상태.
		System.out.println("n + : " + n);
		// → 컴파일 에러 발생
		//variable n might not have been initialized
		// → 지역 변수 n에 접근하여 그 값을 출력하고자 하는 구문



Test071.java
-전역 변수의 초기화 테스트
-전역변수는 클래스의 영역에서 선언됨.
- 인스턴스 생성해서 메모리에 올라감.
-자바가 자동으로 0으로 초기화합니다. 메모리에 올리면서 자동으로 설정.
- 자바는 메모리에 직접적인 접근을 허용하지 않는다.

Test072.java
-클래스와 인스턴스
// 직사각형 클래스 설계 실습

/*
직사각형의 넓이와 둘레 계산 → 클래스 표현

클래스의 정체성 → 직사각형
클래스의 속성   → 『가로,세로』, 넓이, 둘레, 부피, 무게, 재질, 색깔... 등
클래스의 기능   → 넓이 계산, 둘레 계산, 가로세로 입력, 결과 출력...등



객체를 구성     → 데이터(속성, 상태) + 기능(동작, 행위)
	↓
클래스를 설계   →		 변수         +      메소드

클래스 만들기 단계
① 변수 뭐하지?
② 메소드 뭐하지?
③ 메소드 매개변수 뭐하지?

클래스 설계도를 작성하면 인스턴스 생성을 먼저해야함

인스턴스 변수, 인스턴스 생성될 때, 메모리  할당받아요
멤버변수 == 전역변수 == 인스턴스 변수

반환자료형(반환되는 곳에 : 호출한 곳에 두고올거) 메소드명()
{
}
void는 출력만 합니다. 그 위치에 문자열 두고 오는게 아님.
// ※ 하나의 자바 파일 (.java)에 여러 개의 클래스(class)를 설계 할 수 있나???
// 	  : Yes
//    ★하지만, 『public class』는 하나만 올 수 있다.★
//    main()이 없는 java파일도 있다~
// 일반적으로는 하나의 파일에 하나의 클래스를 설계한다.
// 또한, 여러 개의 클래스가 설계된 파일을 컴파일하게 되면
// ★내부에 설계된 클래스의 수 만큼 클래스 파일(.class)이 파생된다.★

객체를 생성해야 메모리에 할당이 됩니다.

Test073.java
//※ CircleTest.java 파일과 세트 ~!!

// 원의 넓이와 둘레 구하기
// 원의 넓이와 둘레를 구할 수 있는 클래스를 설계한다.
// (클래스명 : CircleTest) → CircleTest.java
// BufferedReader의 readLine() 활용.

// 원의 넓이 = 반지름 * 반지름 * 3.141592
// 원의 둘레 = 반지름 * 2 * 3.141592

// 실행 예)
// 반지름 입력 : xx


// >> 반지름이 xx인 원의
// >> 넓이 : xx.xx
// >> 둘레 : xx.xx
// 계속하려면 아무 키나 누르세요....
import java.io.IOException;
//인스턴스 생성할때, import가 필요없는 이유는????????
// ▶▶▶▶▶▶▶▶ 물리적으로 같은 디렉토리안에 있어서

??? 클래스 기반 인스턴스 생성
??? 인스턴스 생성
??? 객체 생성

Test074.java

// 사용자로부터 임의의 정수를 입력받아
// 1 부터 입력받은 수 까지의 합을 연산하여
// 결과값을 출력하는 프로그램을 구현한다.

//단, 클래스와 인스턴스의 개념을 활용하여 처리할 수 있도록 한다.
// 또한, 입력 처리 과정에서 BufferedReader의 readLine()을 사용하며,
// 입력 데이터가 1보다 작거나 1000보다 큰 경우
// 다시 입력 받을 수 있는 처리를 포함하여 프로그램을 구현할 수 있도록 한다.

//실행 예)
//임의의 정수 입력 (1~1000) : 1050
//임의의 정수 입력 (1~1000) : -45
//임의의 정수 입력 (1~1000) : 100
// >> 1 ~ 100 까지의 합 : 5050
// 계속하려면 ............

생성한 인스턴스를 통해 입력 메소드 호출 
 : 참조변수 활용

Test075.java
// 사용자로부터 임의의 두 정수와 연산자를 입력받아
// 해당 연산을 수행하는 프로그램을 구현한다.
// 단, 클래스와 인스턴스의 개념을 활용하여 작성할 수 있도록 한다.

// 실행 예)
// 임의의 두 정수 입력 (공백 구분) : 10 5
// 임의의 연산자 입력 ( + - * /) : +
// >> 10 + 5 = 15
switch문에서 default : 경우의 수가 없으면 디폴트값..

Test076.java
-생성자(Constructor)

○ 생성자(Constructor)의 역할
 
   1. 인스턴스 생성 → 메모리 할당
   2. 초기화

○ 생성자(Constructor)의 특징

   1. 생성자는 메소드이지만, 일반 메소드처럼 호출될 수 없으며,
   							_______________
							자주 호출 불가
      반환 자료형을 가질 수 없다.
	  (『void』 조차 가질 수 없으며, 값을 반환할 수도 없다.)
	  return 있으면 안된다.

	2. 생성자는 클래스와 동일한 이름을 가져야 한다.
	   (대소문자 명확히 구분)
	
	3. 생성자는 객체를 생성하는 과정에서 『new생성자();』의 형태로 호출한다.
	   (인스턴스 생성 시 단 한 번만 호출)
	   __________________________________
	   이러한 특징 때문에 final 변수 초기화가 가능하다.

/*				 // ★ 사용자 정의 생성자가 존재하지 않을 경우
	NumberTest() // -- 컴파일 과정에서 자동으로 삽입되는 『디폴트 생성자』
				 //    (default Constructor)
				 //    클래스 이름과 같은 메소드를 만들어 주고
				 //    텅 비어있는 상태, 매개변수 없는 메소드.
				 //    눈에 보이지는 않지만.

전역변수는 자바가 0으로 초기화 해줌.
별도로 생성자 만들었다면 디폴트 생성자가 만들어지지 않는다.

Test077.java
-생성자(Constructor)
-사용자 정의 생성자가 있으면 디폴트 생성자가 자동으로 생성되지 않는다.

Test078.java
Test079.java
Test080.java
Test081.java
Test082.java
Test083.java
Test084.java
Test085.java
Test086.java





	