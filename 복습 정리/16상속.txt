Test113.java
-클래스 고급
// 상속(Inheritance)

/*
○ 상속(Inheritance)이란
   새로 설계(생성)하고자 하는 클래스가
   이미 설계되어 있는 다른 클래스의 기능과 중복되는 경우
   이미 설계된 클래스의 일부분이나 전체 구조를 공유할 수 있도록 하는 기능을 의미한다.

   즉, 상속은 객체를 좀 더 쉽게 만들 수 있는
   고수준의 재사용성(reusability)을 확보하고
   객체간의 관계를 구성함으로써
   객체 지향의 또 다른 특징인 『다형성』의 문법적 토대가 된다.

   상속은 기존 프로그램의 클래스 내용을 공유함으로써
   중복된 코드들을 재작성할 필요 없이
   반복적이고 세부적인 작업을 처리하지 않기 대문에
   프로그램을 작성하는 시간을 절약할 수 있고
   유지보수를 편리하게 할 수 있으며,
   프로그램의 길이도 짧아지게 된다.

   또한, 이미 작성된 프로그램들은 앞서 테스트되었기 때문에
   오류를 줄일 수 있어 현재 작성 중인 프로그램에만 전념할 수 있다.

※ 주의할 점 ★★★★★
   자바는 『다.중.상.속』을 지원하지 않기 때문에
   두 개 이상의 클래스로부터 상속받을 수 없다.

   자바는 『단.일.상.속』만 지원한다.

자바에서 상속은 자식이 "우리 부모님 누구야 ~!!!!" 하는 거!
*/
// 상위 클래스 == 부모 클래스 == Super클래스 → 물려주는 클래스
// 하위 클래스 == 자식 클래스 == Sub 클래스  → 상속받는 클래스


// 접근제어지시자 default vs protected
//                           ---------
//                 상속x       상속o

-자식클래스명 extends 부모클래스
-extends하는 순간
 부모의 모든것이 상속된다. 하지만!!!!
 생성자는 상속대상에서 제외.
 접근제어지시자 default도 상속에서 제외.
 (같은 패키지면 접근 가능하다.)

※ 모든 자식 클래스의 생성자 안에는 부모 클래스의 생성자 호출이 포함된다.
   생성자 문법 : 생성자 내부에서 또다른 생성자를 호출하는 문법
                 가능하다. 단, 생성자 내부에서 가장 먼저 실행된다.

※ this(0); 클래스명으로 직접부르는것은 불가능하다
            → static 문법이다. 그래서 부모 클래스도 직접적으로 명시 불가능
                                                         → super키워드 사용.
            this는 이 키워드가 포함된 클래스 따라가기
            super은 포함된 클래스의 부모(상위)클래스로 치환

Test114.java
-클래스 고급
// 상속(Inheritance)

// ※ super

// static 으로 선언되지 않은 메소드에서 사용되며 → 클래스변수 ,메소드에서는 클래스명을 대놓고 쓸 수 있다. static이없어야 this랑 super가능.
// 현재 클래스가 상속받는 상위 클래스의 객체를 가리킨다.
// super 는 상위 클래스의 생성자를 호출하거나
// 상위 클래스의 멤버 변수 또는 메소드를 호출할 때 사용할 수 있다.

// 하위 클래스의 생성자에서 상위 클래스의 생성자를 호출할 때에는
// 하위 클래스의 생성자 정의 구문에서 맨 처음에만 위치할 수 있다. → 생성자 문법 : 내부에서 다른 생성자 호출 가능, 가장 먼저 호출. 메소드 내부에서 순차적가능

// ※ 생성자와 클래스 상속간의 관계

//    하위 클래스는 상위 클래스의 멤버를 상속받지만,
//    생성자는 상속 대상에서 제외된다.
//    그리고 하위 클래스의 생성자가 호출될 때
//    자동으로 상위 클래스의 생성자를 호출하게 된다.
//    이 때, 상위 클래스의 생성자는
//    인수가 없는 생성자(default 생성자 형태)가 호출된다. → 자동으로 될 때만!

// 상위 클래스 및 하위 클래스 (즉, 상속 관계에 있는 클래스)를 설계하는 과정에서
// 상위 클래스의 생성자를 정의하지(작성하지) 않거나 → 디폴트 생성자
// 인수가 없는 생성자만을 정의한(작성한) 경우 → 디폴트 생성자
// 명시적으로 하위 클래스에서 상위 클래스의 생성자를 호출하지 않아도
// 아무런 문제가 발생하지 않지만
// 상위 클래스에 인자가 있는 생성자만 존재하는 경우에는
// 주의해야 한다.

// 예를 들어 .... 다음에서 ...
/*
	class A_class
	{
		A_class(int n)
		{
		}
	}

	class B_class extends A_class
	{
		B_class()
		{
			super();
		}
	}
*/
// 하위 클래스인 B_class 의 생성자에서
// 명시적으로 A_class의 생성자를 호출하지 않으면
// 자동으로 인자가 없는 생성자를 호출한다.
// 하지만, A_class 에는 인자가 있는 생성자만 존재하고
// 인자가 없는 생성자는 존재하지 않기 때문에 에러 발생한다.
// 따라서, B_class 생성자의 선두에
// 다음처럼 명시적으로 상위 클래스의 생성자 호출 구문을
// 작성해야 한다.
/*
	class A_class
	{
		A_class(int n)
		{
		}
	}

	class B_class extends A_class
	{
		B_class()
		{
			super(10);
			...
			...
		}
	}
*/

※ 상속 시 주의할 사항
   
   상위 클래스에서 선언된 멤버 변수의 이름과
   하위 클래스에서 선언된 멤버 변수의 이름이 같으면
   상위 클래스의 멤버 변수는 무시된다.
   이 때, 상위 클래스의 멤버 변수를 사용하기 위해서는
   『super』 키워드를 이용한다.

   동일한 이름의 멤버 변수나 동일한 이름의 메소드가
   한 클래스 안에 선언되거나 정의되는 경우 기본적으로 에러 발생한다.
   단, 메소드의 경우에는 매개변수의 갯수나 타입이 다른 경우
   에러가 발생하지 않고 이들을 서로 다른 메소드로 취급하게 된다.
	→ 메소드 오버로딩.
*/

// 삼국지전편							super.삼국지전편    
// (내가 원래 갖고 있던 것)				(부모님으로부터 물려받은 것)


상속 대상에서 제외
-생성자(나중에 자식 생성자에서 디폴트생성자 자동호출 , 이거 싫으면 명시적으로 해줘)
-defalt, private 은 불가.
-clac(매개변수) 여기서 매개변수는 지역변수임.
@Override //-- 어노테이션(annotation) - metadata - JDK 1.5
	          //   컴파일해도 사라지지 않는 주석
==========================================================================
※ 메소드 오버라이딩(Method Overriding)
	//    
	//    상위 클래스를 상속받은 하위 클래스에서
	//    상위 클래스에 정의된 메소드를 다시 정의하는 것으로(재정의)
	//    객체 지향 프로그래밍의 특징인 다형성을 나타낸다.
	//    재정의(Overriding)는 반드시 상속 관계에 있어야 하며,
	//    메소드 이름, 리턴 타입, 매개변수의 갯수나 타입이
	//    완전히 일치해야 한다.

★★★오버라이딩 vs 오버로딩!!★★★
오버라이딩은 상속관계에서 메소드를 재정의하는 것
오버로딩은 메소드 이름이 원래는 달라야하는데 매개변수의 갯수나
자료타입이 다르면 메소드 이름 같은 걸 허용하는 것!!

/*
==========================================================================
상위 클래스		|	하위 클래스		 | 결과
--------------------------------------------------------------------------
생성자를	    |생성자 정의 안함    |→ 가능하다.
정의하지        |인수가 없는 생성자  |→ 가능하다.
않음		    |인수가 있는 생성자  |→ 가능하다.
--------------------------------------------------------------------------
인수가	        |생성자 정의 안함    |→ 가능하다.
없는			|인수가 없는 생성자  |→ 가능하다.
생성자만 정의   |인수가 있는 생성자  |→ 가능하다.
--------------------------------------------------------------------------
인수가			|생성자 정의 안함    |→ 에러 발생.
있는			|인수가 없는 생성자  |→ 상위 클래스의 해당 생성자를 호출하지 않으면 에러 발생. super(10)이면 가능.
생성자만 정의   |인수가 있는 생성자  |→ 상위 클래스의 해당 생성자를 호출하지 않으면 에러 발생. super(10)이면 가능.
==========================================================================
*/
// 상위 클래스에 인수가 있는 생성자 정의 : 사용자 정의 생성자가 있다면
// 하위 클래스는 무족권 사용자 정의 생성자임. 일단.
==========================================================================
Test115.java
-클래스 고급
-상속(Inheritance)
// 다음과 같은 프로그램을 구현한다.
// 단, 상속의 개념을 적용하여 작성할 수 있도록 한다.

// 실행 예)
// 임의의 두 정수 입력(공백 구분):  20 15
// 연산자 입력(+ - * /): -
// >> 20 - 15 = 5.00
// 계속하려면.....

// ※ 문자열.split("구분자")	//-- 구분자 → 공백으로 써라
		//    문자열.split("\\s")	//-- 구분자 → 공백으로 써라
		//    ex)     "10 20 30 40 50".split("\\s");
		//    반환 → {"10","20","30","40","50"}
		//    요소를 문자열로 취하는 배열

		//    ex) "010-1234-1234".split("-");
		//    반환 → {"010","1234","1234"}
		//    요소를 문자열로 취하는 배열

Test116.java
-클래스 고급
-상속(Inheritance)
※ 메소드 오버라이딩(Method Overriding)의 특정
   - 메소드 이름, 리턴타입, 파라미터 수나 타입이 완전히 일치해야 한다.
   - 반드시 상속 관계가 있어야 한다.
   - 재정의된 하위 클래스의 메소드 접근제어지시자는
     상위 클래스의 메소드 접근제어지시자보다 범위가 크거나 같아야 한다.
	 예를 들어, 상위 클래스 메소드의 접근제어지시자가 『protected』인 경우
	 하위 클래스가 이 메소드를 오버라이딩(Overriding)하는 경우
	 접근제어지시자는 『protected』 또는 『public』이어야 한다.
   - 『static』,『final』,『private』 메소드는 오버라이딩(Overriding)할 수 없다.
	  --------
	  이미 클래스가 생성되면서 만들어지고 메모리 잡아서
	  바꾸기 힘듬. 탄생시점이 다름

	              -------
				  상속에 있어서 상수화도 여전~

				  		    ---------
							오버라이딩 전제 조건 상속이 가능해야함.
							private는 상속자체가 불가능! 나만 접근 가능!

   
   - Exception의 추가가 불가능하다.
     즉, 상위 메소드가 가지고 있는 기존 예외 사항에
	 새로운 Exception을 추가하는 것은 불가능 하다는 것이다.
	 자바에서 Exception도 객체입니다! 
	 예외처리를 추가추가추가하면 완전 다른애가 되버령
	 맘대로 Exception을 추가하면 가이드라인이 다 깨져버려!
	 */

System.out.println(((SuperTest116)ob).b);
		//--==>> 10
		// 변수 같은 경우 : 부모 변수, 자식 변수 메모리 위치가 다름
		//                   그래서 이게 가능
하지만!!

((SuperTest116)ob).write();

		// 100
		//	10
		//	Sub write() 메소드 : 100 : 20

	// check~!!
	// 메소드와 변수를 꼭 구분하여 정리할 것
	// 메소드는 오버라이딩하면 부모껄로 못돌아가
	// 근데 부모밑에 자식이 여럿이면 a가 오버라이딩한거
	// b는 그냥 부모꺼 받나? 영향 ㄴㄴ?????????

오버라이딩하면 예전으로 못돌아가~!!~!!