/*=====================================
■■■ 클래스와 인스턴스 ■■■
======================================*/

// 생성자(Constructor)와 초기화 블럭(Initialized Block)

public class Test080
{
	/*
	int n;
	int m;

	n = 100;
	m = 200;

	*/
	/*
	Test080.java:12: error: <identifier> expected
        n = 100;
         ^
	Test080.java:13: error: <identifier> expected
        m = 200;

	Q. 왜 안돼 ..? 『=』 대입연산자.
	A. 연산처리는 클래스ㄴㄴ 메소드!

	*/
	/*
	int n = 100;
	int m = 200;

	// 이건 가능. 선언과 동시에 초기화.
	*/

	int n;
	int m;

	//↓ 초기화 블럭(Initialized Block)
	//   멤버 변수를 초기화 할 수 있구나!~
	{
		n= 20;
		m= 40;
		System.out.println("초기화 블럭 실행...");
	}

	// 생성자(Constructor) 
	// 초기화 블럭이 코드를 먼저 수행했다 하더라도
	// 최종적으로 해당 멤버들의 초기화 값을 결정하게 되는 개념.
	Test080(int n, int m)
	{
		this.n = n;
		this.m = m;
		System.out.println("매개변수 있는 생성자 실행...");
	}
	void write()
	{
		System.out.println("n : " + n + ", m :" + m);
	}

	
	Test080()
	{
		n = 100;
		m = 200;
		System.out.println("생성자 실행 ...");
	}
	
	// → "생성자 실행" 이건 출력안돼. 그래도 생성자 메모리 할당은 돼.
	/*
	초기화 블럭 실행...
	초기화 블럭 실행...
	계속하려면 아무 키나 누르십시오 . . .
	*/

	/*
	Q. 생성자랑 초기화 블럭 중 우선순위는 ?
	A. 초기화 블럭 실행 → 생성자 실행.
	   초기화가 무슨 짓을 해도 생성자가 덮어씀!!!!!!!!!!!
	   생성자 내부에서 생성자를 호출하는 것두 같은 방법.


	*/

	public static void main(String[] args)
	{

		Test080 ob1 = new Test080();
		ob1.write();
		/*
		초기화 블럭 실행...
		생성자 실행 ...
		계속하려면 아무 키나 누르십시오 . . .
		*/

		Test080 ob2 = new Test080(1234,5678);
		ob2.write();

		/*
		초기화 블럭 실행...
		생성자 실행 ...
		초기화 블럭 실행...
		생성자 실행 ...
		계속하려면 아무 키나 누르십시오 . . .
		*/

	}
}

/*
초기화 블럭 실행...
생성자 실행 ...   → 이게 차이점.
n : 100, m :200 → 초기화 한 뒤 생성자() 매개변수 없는거 실행.


초기화 블럭 실행...
매개변수 있는 생성자 실행...→ 이게 차이점.
n : 1234, m :5678
계속하려면 아무 키나 누르십시오 . . .
*/

